






[{"content":" 如何建立虛擬環境 # 下面是假設建立Python 虛擬環境\n第 1 步：建立 Python 虛擬環境 # 虛擬環境就像一個獨立的沙盒，所有安裝的函式庫只會在這個沙盒中生效，不會影響到您系統上其他的 Python 專案。\n開啟終端機(Terminal)。\n使用 conda 建立新的虛擬環境： conda 是 Anaconda 的套件管理器，建立虛擬環境非常方便。我們將建立一個名為 gemini-env 的新環境，並指定使用 Python 3.11 版本，因為它是目前穩定且推薦的版本。\nconda create --name gemini-env python=3.11 系統會詢問您是否確認安裝，請輸入 y 並按下 Enter。\n第 2 步：啟動新的虛擬環境 # 建立完成後，您需要啟動這個虛擬環境，之後的所有操作都將在這個環境中進行。\n啟動 gemini-env 環境：\nconda activate gemini-env ✅ 確認： 成功啟動後，您的終端機提示符前面應該會從 (base) 變成 (gemini-env)。這表示您現在已經在全新的、乾淨的環境中了。\n第 3 步：安裝所有必要的函式庫 # 現在我們在新的虛擬環境中，可以放心地安裝所有開發 Gemini 小程式所需的函式庫了。我們將使用 pip 來安裝，但這次因為環境是乾淨的，不會有舊的依賴衝突。\n確保 pip 本身是最新的：\npython -m pip install --upgrade pip 安裝所有開發 Gemini 後端所需的函式庫： 一次性安裝所有函式庫會更有效率。 pip install fastapi uvicorn python-multipart google-generativeai httpx 💡 備註： 如果您之前遇到 grpcio 的編譯問題，這一次因為我們是在一個乾淨的環境中安裝，通常會順利很多。如果還是遇到問題，可以嘗試使用 conda 來安裝這幾個套件：\nBash\nconda install -c conda-forge google-generativeai httpx 然後再用 pip 安裝其他幾個。\n第 4 步：設定 Gemini API 金鑰 現在環境已經準備好，我們來設定金鑰，以便程式可以正確呼叫 Gemini API。\n建立一個 .env 檔案： 在您的專案資料夾中（也就是您存放 main.py 和 index.html 的地方），建立一個新檔案，並將其命名為 .env。\n編輯 .env 檔案： 在檔案中加入以下內容，並將 您的_GEMINI_API_金鑰 替換為您的實際金鑰：\n程式碼片段\nGEMINI_API_KEY=\u0026ldquo;您的_GEMINI_API_金鑰\u0026rdquo; 安裝 python-dotenv 函式庫： 我們需要這個函式庫來讓 FastAPI 應用程式能夠讀取 .env 檔案中的金鑰。\nBash\npip install python-dotenv 修改 main.py： 在 main.py 的最上方，新增這兩行程式碼來載入 .env 檔案。\nPython\nimport os from dotenv import load_dotenv\nload_dotenv() # 在這裡載入環境變數\n\u0026hellip; 後續的程式碼 # GEMINI_API_KEY = os.getenv(\u0026ldquo;GEMINI_API_KEY\u0026rdquo;, \u0026ldquo;\u0026rdquo;) # 這行可以保留，但現在它會從 .env 讀取金鑰了 # 第 5 步：運行您的 FastAPI 應用程式 現在，所有環境和設定都已完成，您可以運行您的應用程式了。\n在同一個終端機視窗中 (確保 (gemini-env) 仍然是啟動狀態)，導航到您的專案資料夾。\nBash\ncd /您的/專案/資料夾/路徑 運行 Uvicorn 伺服器：\nBash\nuvicorn main:app \u0026ndash;reload 如果一切順利，您會看到 Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) 的訊息。\n如何管理虛擬環境和節省空間 如果您未來不再需要某個專案的虛擬環境，您可以隨時將它移除來釋放空間。\n開啟終端機。\n移除虛擬環境：\nBash\nconda env remove \u0026ndash;name gemini-env 這個命令會完全刪除名為 gemini-env 的虛擬環境，所有安裝在裡面的函式庫也會被一併刪除，並釋放出佔用的儲存空間。\n總結來說，虛擬環境雖然會佔用一些空間，但它提供了一個乾淨、隔離的開發環境，可以避免許多混亂和錯誤，是一個非常值得的選擇。\n這個問題問得很好，要查看您目前有哪些虛擬環境，有兩種常用的 conda 命令可以做到。\n如何查看所有虛擬環境 請在您的 Mac 終端機中，輸入以下任一命令並按下 Enter：\nconda env list\nconda info \u0026ndash;envs\n這兩個命令的功能完全相同，都會列出您所有已建立的虛擬環境。\n輸出範例 當您執行命令後，您會看到類似以下的輸出：\nconda environments: # # base * /Users/1020824woaixiaoxiong/opt/anaconda3 gemini-env /Users/1020824woaixiaoxiong/opt/anaconda3/envs/gemini-env my-project-env /Users/1020824woaixiaoxiong/opt/anaconda3/envs/my-project-env 如何解讀輸出 第一欄 (base, gemini-env, my-project-env)：這是您為虛擬環境取的名字。\n星號 (*)：星號旁邊的環境表示這是您目前正在使用的活動環境 (active environment)。例如，在上面的範例中，base 環境是目前啟動的。\n第二欄 (路徑)：這是每個虛擬環境在您電腦上的實際儲存位置。\n如果您想切換到 gemini-env 環境，只需執行 conda activate gemini-env，然後再次執行 conda env list，您就會看到星號移動到 gemini-env 旁邊了。\n","externalUrl":null,"permalink":"/code/vertual_env/","section":"Codes","summary":"\u003ch1 class=\"relative group\"\u003e如何建立虛擬環境 \n    \u003cdiv id=\"如何建立虛擬環境\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e8%99%9b%e6%93%ac%e7%92%b0%e5%a2%83\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e下面是假設建立Python 虛擬環境\u003c/p\u003e","title":"","type":"code"},{"content":"Given a string s, find the length of the longest substring without duplicate characters.\nExample 1:\nInput: s = \u0026ldquo;abcabcbb\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3.\nExample 2:\nInput: s = \u0026ldquo;bbbbb\u0026rdquo;\nOutput: 1\nExplanation: The answer is \u0026ldquo;b\u0026rdquo;, with the length of 1.\nExample 3:\nInput: s = \u0026ldquo;pwwkew\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3.\nNotice that the answer must be a substring, \u0026ldquo;pwke\u0026rdquo; is a subsequence and not a substring.\nConstraints:\n0 \u0026lt;= s.length \u0026lt;= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n這題的需求是要找到沒有重複，duplicate代表重複，的最長連續字串。\n在條件裡有寫說，該字串只有英文單字，而英文單字總共26個\n那我們可以建立一個陣列檢查該英文單字是否已經出現過。\nboolean [] visited=new boolean[26]; 建立兩個指針，先都放在開頭，設置一個max當作最長長度\n使用while迴圈只動其中一個。\nint s=0,e=0; while(e\u0026lt;s.length) 當指針e往下一個走時，如果visited沒有看過，那就continue\n否則就要讓s指針前進，直到visited清除看過的痕跡\n在清除之前先計算當前長度是否比較長\nif(visited[s.charAt(e)-\u0026#39;a\u0026#39;]) e++; continue; else max=Math.max(max,e-a); while(visited[s.charAt(e)-\u0026#39;a\u0026#39;]){ visited[s.charAt(s)-\u0026#39;a\u0026#39;]=false; s++; } 那最後在送出答案前在檢查一次答案\nreturn Math.max(max,e-a); 合其來就是\nint [] visited=new int[26]; int s=0,e=0; while(e\u0026lt;s.length){ if(visited[s.charAt(e)-\u0026#39;a\u0026#39;]) continue; else max=Math.max(max,e-a); while(visited[s.charAt(e)-\u0026#39;a\u0026#39;]){ visited[s.charAt(s)-\u0026#39;a\u0026#39;]=false; s++; } } return Math.max(max,e-a); ","externalUrl":null,"permalink":"/leetcode/3-longest-substring-without-repeating-characters/","section":"LeetCode解題","summary":"\u003cp\u003eGiven a string s, find the length of the longest substring without duplicate characters.\u003c/p\u003e\n\u003cp\u003eExample 1:\u003c/p\u003e\n\u003cp\u003eInput: s = \u0026ldquo;abcabcbb\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eOutput: 3\u003c/p\u003e\n\u003cp\u003eExplanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3.\u003c/p\u003e","title":"3. Longest Substring Without Repeating Characters","type":"leetcode"},{"content":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n這題要得到是兩個陣列中的中間值\n為了要得到中間值，將兩個陣列合併\n中間的index即是答案\nclass Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { if(nums1.length\u0026gt;nums2.length){ return findMedianSortedArrays(nums2,nums1); } int len1=nums1.length,len2=nums2.length; int left=0,right=len1; while(left\u0026lt;=right){ int part1=(left+right)/2; int part2=(left+right+1)/2-part1; int maxl1=(part1==0)?Integer.MIN_VALUE : nums1[part1 - 1]; int minr1=(part1==len1)?Integer.MAX_VALUE : nums1[part1]; int maxl2=(part2==0)?Integer.MIN_VALUE : nums2[part2 - 1]; int minr2=(part2==len2)?Integer.MAX_VALUE : nums2[part2]; if(maxl1\u0026lt;=minr2\u0026amp;\u0026amp;maxl2\u0026lt;=minr1){ if((len1+len2)%2==0){ return (Math.max(maxl1,maxl2)+Math.min(minr1,minr2))/2.0 }else{ return (double)Math.max(maxl1,maxl2); } }else if(maxl2\u0026gt;minr2) right=part1-1; else left=part1+1; } return 0.0; } } ","externalUrl":null,"permalink":"/leetcode/4-median-of-two-sorted-arrays/","section":"LeetCode解題","summary":"\u003cp\u003eGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\u003c/p\u003e\n\u003cp\u003eThe overall run time complexity should be O(log (m+n)).\u003c/p\u003e","title":"4. Median of Two Sorted Arrays","type":"leetcode"},{"content":"Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = \u0026ldquo;babad\u0026rdquo;\nOutput: \u0026ldquo;bab\u0026rdquo;\nExplanation: \u0026ldquo;aba\u0026rdquo; is also a valid answer.\nExample 2:\nInput: s = \u0026ldquo;cbbd\u0026rdquo;\nOutput: \u0026ldquo;bb\u0026rdquo;\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 1000\ns consist of only digits and English letters.\n先從分析題目開始\n題目要找的是最長的palindromic substring\npalindromic是指從前或從後讀起來都相同的意思\n因此palindromic substring 代表的是類似「八百八」、「美而美」、「美美而美美」的回文\n那因此我們需要頭跟尾巴同時有一樣的字元才行。\n如果要找到最長回文，比起漫無目的搜尋頭尾。\n可以換成是先設定中心，在從左右尋找是否為相同字元。\nprivate static int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L \u0026gt;= 0 \u0026amp;\u0026amp; R \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(L) == s.charAt(R)) { L--; R++; } return R - L - 1; } 可以看到left,right是從中心向外擴散的 因此當L跟R不同時，就代表回文斷掉了 那接著就是要做兩件事\n建立每個字元都是中心點 對比出最長長度 注意中心有可能是一個或兩個 //所以點遍歷一遍 for (int i = 0; i \u0026lt; s.length(); i++) { // 當中心僅一個 int len1 = expandAroundCenter(s, i, i); // 當中心有兩個 int len2 = expandAroundCenter(s, i, i + 1); // 對比出最長長度 int len = Math.max(len1, len2); if (len \u0026gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } 那接著所有元素組合再一起就看起來像下方。\nclass Solution { public String longestPalindrome(String s) { if(s.length()\u0026lt;1||s==null){ return \u0026#34;\u0026#34;; } int start=0,end=0; for (int i = 0; i \u0026lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len \u0026gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } private static int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L \u0026gt;= 0 \u0026amp;\u0026amp; R \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(L) == s.charAt(R)) { L--; R++; } return R - L - 1; } } python 寫法\ndef longest_palindrome(s: str) -\u0026gt; str: if s is None or len(s) \u0026lt; 1: return \u0026#34;\u0026#34; start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) # 單中心 len2 = expand_around_center(s, i, i + 1) # 雙中心 max_len = max(len1, len2) if max_len \u0026gt; end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s: str, left: int, right: int) -\u0026gt; int: L, R = left, right while L \u0026gt;= 0 and R \u0026lt; len(s) and s[L] == s[R]: L -= 1 R += 1 return R - L - 1 ","externalUrl":null,"permalink":"/leetcode/5-longest-palindromic-substring/","section":"LeetCode解題","summary":"\u003cp\u003eGiven a string s, return the longest palindromic substring in \u003cstrong\u003es\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eExample 1:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eInput: s = \u0026ldquo;babad\u0026rdquo;\u003cbr\u003e\nOutput: \u0026ldquo;bab\u0026rdquo;\u003cbr\u003e\nExplanation: \u0026ldquo;aba\u0026rdquo; is also a valid answer.\u003cbr\u003e\n\u003cbr\u003e\nExample 2:\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eInput: s = \u0026ldquo;cbbd\u0026rdquo;\u003c/p\u003e","title":"5.Longest Palindromic Substring","type":"leetcode"},{"content":"The string \u0026ldquo;PAYPALISHIRING\u0026rdquo; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP A H N\nA P L S I I G\nY I R\nAnd then read line by line: \u0026ldquo;PAHNAPLSIIGYIR\u0026rdquo;\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);\nExample 1:\nInput: s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 3\nOutput: \u0026ldquo;PAHNAPLSIIGYIR\u0026rdquo;\nExample 2:\nInput: s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 4\nOutput: \u0026ldquo;PINALSIGYAHRPI\u0026rdquo;\nExplanation:\nP I N\nA L S I G\nY A H R\nP I\nExample 3:\nInput: s = \u0026ldquo;A\u0026rdquo;, numRows = 1\nOutput: \u0026ldquo;A\u0026rdquo;\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 1000\ns consists of English letters (lower-case and upper-case), \u0026lsquo;,\u0026rsquo; and \u0026lsquo;.\u0026rsquo;.\n1 \u0026lt;= numRows \u0026lt;= 1000\n我們先從分析題目需求開始\n他說\u0026quot;PAYPALISHIRING\u0026quot;是以 zigzag pattern方式寫的\nzigzag是指寫法是先以上到下再由左下寫到右上的寫法，但實際讀出來會是由左到右再從上到下\n算是密碼學中很常見的加密方式。\nnums=上到下的長度。\n","externalUrl":null,"permalink":"/leetcode/6-zigzag-conversion/","section":"LeetCode解題","summary":"\u003cp\u003eThe string \u0026ldquo;PAYPALISHIRING\u0026rdquo; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\u003c/p\u003e","title":"6.Zigzag Conversion","type":"leetcode"},{"content":"Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123\nOutput: 321\nExample 2:\nInput: x = -123\nOutput: -321\nExample 3:\nInput: x = 120\nOutput: 21\n先從分析題目開始\n題目的要求是反轉數字\n那是什麼種類的反轉呢？\n根據問題描述，希望得到數字從右到左翻轉，且前面的0不計算的整數\n那不管如何，如果要拆解這個數字的話，就可以從字長跟字尾開始\n想法是：先將數字轉成string獲取字長，使用10的倍數去對數字進行向上加的動作\nString cut=Integer.toString(Math.abs(x)); int len=cut.length(); 將個位數跟數字使用Math.pow(平方)\nwhile(len\u0026gt;0){ int modNum=x%10; ans+=modNum*Math.pow(len,10); x/=10; len--; } 最後加總起來的數字即為反轉數字\n合併如下\nclass Solution { public int reverse(int x) { String cut=Integer.toString(Math.abs(x)); int len=cut.length()-1; int ans=0; while(len\u0026gt;=0){ int modNum=x%10; ans+=modNum*Math.pow(10,len); x/=10; len--; } ans=ans\u0026gt;=Math.pow(2,31)-1||ans\u0026lt;=Math.pow(-2,31)+1?0:ans; return ans; } } ","externalUrl":null,"permalink":"/leetcode/7-reverse-integer/","section":"LeetCode解題","summary":"\u003cp\u003eGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\u003c/p\u003e","title":"7.Reverse Integer","type":"leetcode"},{"content":"Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\nWhitespace: Ignore any leading whitespace (\u0026quot; \u0026ldquo;).\nSignedness: Determine the sign by checking if the next character is \u0026lsquo;-\u0026rsquo; or \u0026lsquo;+\u0026rsquo;, assuming positivity if neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\nReturn the integer as the final result.\nExample 1:\nInput: s = \u0026ldquo;42\u0026rdquo;\nOutput: 42\nExplanation:\nThe underlined characters are what is read in and the caret is the current reader position. Step 1: \u0026ldquo;42\u0026rdquo; (no characters read because there is no leading whitespace) ^ Step 2: \u0026ldquo;42\u0026rdquo; (no characters read because there is neither a \u0026lsquo;-\u0026rsquo; nor \u0026lsquo;+\u0026rsquo;) ^ Step 3: \u0026ldquo;42\u0026rdquo; (\u0026ldquo;42\u0026rdquo; is read in) ^ Example 2:\nInput: s = \u0026quot; -042\u0026rdquo;\nOutput: -42\nExplanation:\nStep 1: \u0026quot; -042\u0026quot; (leading whitespace is read and ignored) ^ Step 2: \u0026quot; -042\u0026quot; (\u0026rsquo;-\u0026rsquo; is read, so the result should be negative) ^ Step 3: \u0026quot; -042\u0026quot; (\u0026ldquo;042\u0026rdquo; is read in, leading zeros ignored in the result) ^ Example 3:\nInput: s = \u0026ldquo;1337c0d3\u0026rdquo;\nOutput: 1337\nExplanation:\nStep 1: \u0026ldquo;1337c0d3\u0026rdquo; (no characters read because there is no leading whitespace) ^ Step 2: \u0026ldquo;1337c0d3\u0026rdquo; (no characters read because there is neither a \u0026lsquo;-\u0026rsquo; nor \u0026lsquo;+\u0026rsquo;) ^ Step 3: \u0026ldquo;1337c0d3\u0026rdquo; (\u0026ldquo;1337\u0026rdquo; is read in; reading stops because the next character is a non-digit) ^ Example 4:\nInput: s = \u0026ldquo;0-1\u0026rdquo;\nOutput: 0\nExplanation:\nStep 1: \u0026ldquo;0-1\u0026rdquo; (no characters read because there is no leading whitespace) ^ Step 2: \u0026ldquo;0-1\u0026rdquo; (no characters read because there is neither a \u0026lsquo;-\u0026rsquo; nor \u0026lsquo;+\u0026rsquo;) ^ Step 3: \u0026ldquo;0-1\u0026rdquo; (\u0026ldquo;0\u0026rdquo; is read in; reading stops because the next character is a non-digit) ^ Example 5:\nInput: s = \u0026ldquo;words and 987\u0026rdquo;\nOutput: 0\nExplanation:\nReading stops at the first non-digit character \u0026lsquo;w\u0026rsquo;.\nConstraints:\n0 \u0026lt;= s.length \u0026lt;= 200 s consists of English letters (lower-case and upper-case), digits (0-9), \u0026rsquo; \u0026lsquo;, \u0026lsquo;+\u0026rsquo;, \u0026lsquo;-\u0026rsquo;, and \u0026lsquo;.\u0026rsquo;.\n我們先來分析題目的條件。\n從前面讀到的空白跟第一個+或-要跳過\n//i等於s的指標 n=s的長度 while(i \u0026lt; n \u0026amp;\u0026amp;s.charAt(i)=\u0026#39; \u0026#39;) i++; if(i \u0026lt; n \u0026amp;\u0026amp; s.charAt(i)=\u0026#39;+\u0026#39;) i++; if(i \u0026lt; n \u0026amp;\u0026amp; s.charAt(i)=\u0026#39;-\u0026#39;) i++; isN=true; 遇到數值時，將現在的數值*10再加上數字就可以直接算成功。 Ex: \u0026ldquo;340\u0026rdquo;\n取出3 result=3;\n取出4 result=result10=30 num=4 result=result10+num=34\n取出0 result=result10=340 num=0 result=result10+num=340\nint num = s.charAt(i) - \u0026#39;0\u0026#39;; result = result * 10 + num; 當數值大於2^32或小於-2^32，將成為Integer.MIN_VALUE或是Integer.MAX_VALUE\nif(isN \u0026amp;\u0026amp; -result \u0026lt;= Integer.MIN_VALUE) return Integer.MIN_VALUE; else if(!isN \u0026amp;\u0026amp; result \u0026gt;= Integer.MAX_VALUE) return Integer.MAX_VALUE; 將上面的Code合併起來就是\nclass Solution { public int myAtoi(String s) { if(s == null || s.length() == 0) return 0; int start = 0, n = s.length(); boolean isN = false; while(start \u0026lt; n \u0026amp;\u0026amp; s.charAt(start) == \u0026#39; \u0026#39;) start++; if(start \u0026lt; n \u0026amp;\u0026amp; s.charAt(start) == \u0026#39;+\u0026#39;) { start++; } else if(start \u0026lt; n \u0026amp;\u0026amp; s.charAt(start) == \u0026#39;-\u0026#39;) { isN = true; start++; } long result = 0; for(int i = start; i \u0026lt; s.length() \u0026amp;\u0026amp; Character.isDigit(s.charAt(i)); i++) { int num = s.charAt(i) - \u0026#39;0\u0026#39;; result = result * 10 + num; if(isN \u0026amp;\u0026amp; -result \u0026lt;= Integer.MIN_VALUE) return Integer.MIN_VALUE; else if(!isN \u0026amp;\u0026amp; result \u0026gt;= Integer.MAX_VALUE) return Integer.MAX_VALUE; } return (isN)? (int) -result : (int) result; } } ","externalUrl":null,"permalink":"/leetcode/8-string-to-integer-atoi/","section":"LeetCode解題","summary":"\u003cp\u003eImplement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\u003c/p\u003e\n\u003cp\u003eThe algorithm for myAtoi(string s) is as follows:\u003c/p\u003e\n\u003cp\u003eWhitespace: Ignore any leading whitespace (\u0026quot; \u0026ldquo;).\u003c/p\u003e\n\u003cp\u003eSignedness: Determine the sign by checking if the next character is \u0026lsquo;-\u0026rsquo; or \u0026lsquo;+\u0026rsquo;, assuming positivity if neither present.\u003c/p\u003e","title":"8.String to Integer (atoi) leetcode java解題 附邏輯 中文","type":"leetcode"},{"content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n本題是會給予兩個nodelist，每個node裡包含一個值\n將兩組3個nodelist的值從左到右組成一個自然數\n並將兩組自然數加總後，從左到右回傳nodelist\n解題： # 建立一個\n","externalUrl":null,"permalink":"/leetcode/2-add-two-numbers/","section":"LeetCode解題","summary":"\u003cp\u003eYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\u003c/p\u003e","title":"Add Two Numbers","type":"leetcode"},{"content":"","externalUrl":null,"permalink":"/tags/array/","section":"标签","summary":"","title":"Array","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/code/","section":"Codes","summary":"","title":"Codes","type":"code"},{"content":"","externalUrl":null,"permalink":"/tags/leetcode/","section":"标签","summary":"","title":"Leetcode","type":"tags"},{"content":"LeetCode 是一個知名的在線编程平台，提供豐富的算法和数据结构题目。 無論你是初學者還是求職者，都可以通過刷題提升編程能力，積累實戰經驗，為技術面是做好充足準備。\n","externalUrl":null,"permalink":"/leetcode/","section":"LeetCode解題","summary":"\u003cp\u003eLeetCode 是一個知名的在線编程平台，提供豐富的算法和数据结构题目。\n無論你是初學者還是求職者，都可以通過刷題提升編程能力，積累實戰經驗，為技術面是做好充足準備。\u003c/p\u003e","title":"LeetCode解題","type":"leetcode"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/social/","section":"Socials","summary":"","title":"Socials","type":"social"},{"content":"","externalUrl":null,"permalink":"/tags/sql/","section":"标签","summary":"","title":"SQL","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/sql-%E7%B3%BB%E5%88%97%E4%B8%80/","section":"标签","summary":"","title":"SQL 系列一","type":"tags"},{"content":"在進入 SQL 語法與資料操作之前，我們要先問自己一個問題：我們到底在處理的是什麼資料？\n這就像是想學開車，你得先知道方向盤、油門與車子是怎麼組成的，而不是一上車就猛踩油門。學習 SQL 的第一步，就是建立正確的資料庫「世界觀」。\n🧱 資料是什麼？一切從「表格」開始 # 很多人初學 SQL 時會覺得它很像 Excel。其實這個聯想沒錯，但不夠精確。\n在關聯式資料庫（Relational Database）中，資料是以「表格」的形式存在。這些表格可以互相連結、拆解、過濾、排序，就像一張張有關聯性的電子試算表。\n表格的構成：\nid name age city 1 Alice 28 New York 2 Bob 34 Tokyo 3 Charlie 22 Taipei 這樣的表格就被稱為一張「資料表（Table）」，每一列是「一筆資料（Row）」，每一欄是「一個欄位（Column）」。你寫 SQL，就是為了去查這些資料、整理這些資料，甚至建立與維護這些表格。\n🔗 為什麼叫「關聯式」資料庫？\n所謂「關聯式」的意思，就是表格與表格之間可以建立關聯（Relationship）。比方說，員工資訊在一張表，部門資訊在另一張表，兩張表可以透過「部門代號」這個欄位互相對應起來。\n這樣的設計讓資料更彈性、可維護性高，也就是：\n不用重複資料（資料表之間可分開管理）\n資料一致性更高（修改部門名稱不需修改每位員工）\n查詢更有彈性（可用 JOIN 將多張表結合查詢）\n🔍 常見的資料庫系統：選一個來玩玩吧！ # SQL 語法幾乎是「跨資料庫系統通用的語言」，但資料庫本身有很多種，像是：\n資料庫系統\t特點\t使用場景\nMySQL\t免費、開源、輕量\t中小企業、網站後端常用\nPostgreSQL\t功能強大、支援地理空間查詢\t科學分析、金融、政府系統\nSQLite\t輕巧、無伺服器、單檔運作\t行動 App、本地小型專案\nSQL Server\t微軟出品、商業整合性高\tWindows 生態系、企業內部系統\nOracle\t高穩定性、複雜功能支援\t大型企業、銀行、保險產業\n對初學者來說，推薦從 MySQL 或 SQLite 入門，因為好安裝、資源多，而且可以快速看到成果。\n❓SQL 和 NoSQL 有什麼不同？ # 很多人在學習資料庫時會看到「NoSQL」這個詞，會不小心混淆。\n簡單來說：\n項目\tSQL（關聯式資料庫）\tNoSQL（非關聯式）\n結構\t表格、欄列\t文件、鍵值對、圖形等\n適合情境\t資料結構穩定、資料之間有關聯\t資料結構彈性、不一定要關聯\n查詢語言\t使用 SQL 語法\t各自有 API 或語法（如 MongoDB 查詢語法）\n常見例子\tMySQL、PostgreSQL\tMongoDB、Firebase、Redis\n在進入大數據與非結構化資料之前，SQL 是打好資料邏輯基礎的必經之路。\n🧭 結語：別急著寫 SQL，先理解你要查的「世界」 # 當你想要學好 SQL，請記得第一步不是打開編輯器，而是：\n想清楚「資料是什麼？它們之間有什麼關係？」\n瞭解你所接觸的資料庫長什麼樣子\n選擇一套你能實際操作的資料庫系統開始練習\n建立好這樣的「資料世界觀」後，你的學習會走得比別人更穩，也更快進入狀況。\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-a1/","section":"SQL學習資料分享","summary":"\u003cp\u003e在進入 SQL 語法與資料操作之前，我們要先問自己一個問題：我們到底在處理的是什麼資料？\u003c/p\u003e","title":"SQL 學習第一步：資料庫世界觀建立｜資料從哪裡來，又為什麼這麼重要？","type":"sql"},{"content":"常見的時間範圍查詢場景 按日期區間篩選 例如查詢 2023/01/01 到 2023/03/31 的訂單資料。\n按時間段篩選 例如每天 18:00 - 23:00 的流量。\n按相對時間篩選 例如「最近 7 天」、「今年至今 (YTD)」。\n🔍 基本範圍查詢 # 假設 orders 表結構如下：\norder_id INT order_date DATETIME amount DECIMA 1️⃣ 固定日期區間 # SELECT * FROM orders WHERE order_date \u0026gt;= \u0026#39;2023-01-01\u0026#39; AND order_date \u0026lt; \u0026#39;2023-04-01\u0026#39;; 📌 為什麼不用 \u0026lt;= \u0026lsquo;2023-03-31\u0026rsquo;？ 因為 DATETIME 可能包含時分秒，如果你只用 \u0026lt;=，會錯過 3/31 當天 23:59:59 之後的資料。 最佳做法是「用 \u0026lt; 下一天的 00:00:00」。\n2️⃣ 使用 BETWEEN（需小心精確度） # SELECT * FROM orders WHERE order_date BETWEEN \u0026#39;2023-01-01\u0026#39; AND \u0026#39;2023-03-31 23:59:59\u0026#39;; 📌 BETWEEN 包含頭尾兩端，適合用在已知完整時間範圍的情況。\n⏳ 按時間段篩選 # 如果只想查詢「每天的某個時段」：\nSELECT * FROM orders WHERE HOUR(order_date) BETWEEN 18 AND 23; 📌 效能警告： HOUR(order_date) 會讓索引失效，最好先建立一個「小時欄位」或用資料庫的生成欄位（Generated Column）。\n📅 相對時間篩選 # 1️⃣ 最近 7 天（MySQL） # SELECT * FROM orders WHERE order_date \u0026gt;= NOW() - INTERVAL 7 DAY; 2️⃣ 今年至今（PostgreSQL） # SELECT * FROM orders WHERE order_date \u0026gt;= DATE_TRUNC(\u0026#39;year\u0026#39;, CURRENT_DATE); 3️⃣ 上個月資料（MySQL） # SELECT * FROM orders WHERE order_date \u0026gt;= DATE_FORMAT(CURDATE() - INTERVAL 1 MONTH, \u0026#39;%Y-%m-01\u0026#39;) AND order_date \u0026lt; DATE_FORMAT(CURDATE(), \u0026#39;%Y-%m-01\u0026#39;); 🛠 效能最佳化技巧 避免在 WHERE 直接對欄位套用函數（如 YEAR(order_date) = 2023），改用範圍比較。\n為時間欄位建立索引（INDEX）。\n大批量查詢時，可分批處理（Batch Query）。\n📌 小結 固定時間範圍 → 用 \u0026gt;= 與 \u0026lt; 搭配。\n相對時間 → 善用 NOW()、CURRENT_DATE、DATE_TRUNC。\n避免函數在條件中直接作用，保留索引效能。\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-c2/","section":"SQL學習資料分享","summary":"\u003cp\u003e常見的時間範圍查詢場景\n按日期區間篩選\n例如查詢 2023/01/01 到 2023/03/31 的訂單資料。\u003c/p\u003e","title":"SQL 學習第七步 時間區間篩選技巧：讓查詢更精準與高效","type":"sql"},{"content":"學 SQL 前，你是不是也曾經困惑：\n「SQL 到底是語言還是工具？」\n「為什麼那麼多人說資料分析第一步是學 SQL？」\n「我學會 SELECT * 就代表會 SQL 了嗎？」\n今天就讓我們用最直白的方式來了解 SQL 是什麼，以及它在資料世界中扮演什麼角色。\n💬 SQL 是什麼？一句話定義它 # SQL 是資料庫的語言，就像 Excel 的公式，是與資料對話的工具。\nSQL，全名是 Structured Query Language（結構化查詢語言），是用來「與關聯式資料庫溝通」的一種語言。\n你可以用它來：\n查資料（查出符合條件的訂單）\n改資料（修改使用者的地址）\n建表格（新增一張記錄報表的表）\n控制權限（讓某些人只能看資料，不能改資料）\n它不只是「查詢」語言，更是一整套資料操作語言。\n🧩 SQL 有哪些「語法模組」？ # SQL 語法可以依功能分類為四大類（別背它們，先理解）：\n你最常用的會是 DQL，也就是查資料的 SELECT，但其他類也會在你維護資料庫時逐漸用上。\n🧠 SQL 的三個核心概念 # 1. SQL 是「聲明式」語言\n你只要說出你想要什麼，資料庫就幫你查出來。\n不像 Python 那樣需要寫 for 迴圈，SQL 更像是：\n「嘿資料庫，幫我找出所有訂單金額大於 $1000 的訂單，按時間排序一下。」\n2. SQL 是跨平台的\n大多數資料庫（MySQL、PostgreSQL、SQL Server）都支援 SQL 語法，只差在一些小細節（函式、語法結構）。你學會一次，大致能通用多個系統。\n3. SQL 是資料分析的核心技能之一\n從後端工程師、資料分析師、資料工程師，到商業分析 PM，幾乎都需要會 SQL，因為只要你要分析「儲存在資料庫中的資料」，你就得透過 SQL 來取得它。\n🧭 小結：SQL 是資料世界的語言起點 # SQL 的重要性，就像網頁前端的 HTML，你可能一開始只會寫 SELECT *，但只要持續練習，你會發現它是資料邏輯最重要的通用語言。\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-a2/","section":"SQL學習資料分享","summary":"\u003cp\u003e學 SQL 前，你是不是也曾經困惑：\u003c/p\u003e\n\u003cp\u003e「SQL 到底是語言還是工具？」\u003c/p\u003e\n\u003cp\u003e「為什麼那麼多人說資料分析第一步是學 SQL？」\u003c/p\u003e","title":"SQL 學習第二步：SQL 是什麼？為什麼資料工程師、分析師都離不開它？","type":"sql"},{"content":"在你已經熟悉查詢資料（SELECT）後，下一步就是學會如何對資料進行新增、修改、刪除。這些操作雖然簡單，但在真實系統中卻關係到資料的完整性與安全性。今天我們就把 DML（Data Manipulation Language）一次學透。\n🔹 DML 是什麼？ # DML（資料操作語句）負責對資料進行增（INSERT）、改（UPDATE）、刪（DELETE）。不同於 DDL（資料定義語句）是管理資料表結構，DML 主要影響表中的行內容。\n1️⃣ INSERT INTO — 新增資料 # 單筆插入\nINSERT INTO users (name, email, created\\_at) VALUES (\u0026#39;Alice\u0026#39;, \u0026#39;alice\\@example.com\u0026#39;, NOW()); 📌 小技巧：\n建議指定欄位名稱，避免因表結構變更導致錯位。\nNOW() 可自動插入當前時間。\n多筆插入\nINSERT INTO users (name, email, created\\_at) VALUES (\u0026#39;Bob\u0026#39;, \u0026#39;bob\\@example.com\u0026#39;, NOW()), (\u0026#39;Charlie\u0026#39;, \u0026#39;charlie\\@example.com\u0026#39;, NOW()); 💡 多筆一次插入比多次單筆插入效能更好。\n2️⃣ UPDATE — 修改資料 # UPDATE users SET email = \u0026#39;alice\\_new\\@example.com\u0026#39; WHERE name = \u0026#39;Alice\u0026#39;; ⚠ 安全提醒：\n一定要加 WHERE 條件，否則會更新全表。\n可以先用 SELECT 測試條件：\nSELECT \\* FROM users WHERE name = \u0026#39;Alice\u0026#39;; 3️⃣ DELETE — 刪除資料 # DELETE FROM users WHERE name = \u0026#39;Bob\u0026#39;; ⚠ 刪除安全守則：\n永遠先 SELECT 確認條件。\n若可能後悔，先用「軟刪除」：\nUPDATE users SET deleted\\_at = NOW() WHERE name = \u0026#39;Bob\u0026#39;; （再透過 WHERE deleted_at IS NULL 過濾）\n🛠 真實應用技巧 # 批次處理\n大量更新或刪除時，分批執行避免鎖表：\nDELETE FROM logs WHERE created\\_at \\\u0026lt; \u0026#39;2023-01-01\u0026#39; LIMIT 1000; 事務保護（Transaction）\n防止錯誤操作：\nSTART TRANSACTION; DELETE FROM orders WHERE id = 123; ROLLBACK; -- 若發現錯誤 COMMIT; -- 確認後提交 📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-d1/","section":"SQL學習資料分享","summary":"\u003cp\u003e在你已經熟悉查詢資料（SELECT）後，下一步就是學會如何對資料進行新增、修改、刪除。這些操作雖然簡單，但在真實系統中卻關係到資料的完整性與安全性。今天我們就把 DML（Data Manipulation Language）一次學透。\u003c/p\u003e","title":"SQL 學習第八步 DML 全攻略：INSERT、UPDATE、DELETE 的安全與技巧","type":"sql"},{"content":"學 SQL 最直接的一步就是：「我想看資料，那要怎麼寫？」\n答案只有兩個字：SELECT。\nSELECT 是所有 SQL 語法中的核心，你可以把它當成「我要查詢」的意思，語法結構就像是和資料庫對話：\n📣 「欸，幫我找一下這個表格裡面的這幾個欄位，記得條件是這樣，還有請排序一下。」 # 這篇文章，就是要讓你熟練這句話該怎麼翻成 SQL。\n🧪 最基本的 SELECT 語法長這樣 # SELECT 欄位名稱 FROM 資料表名稱; 範例：\n假設我們有一個 employees 表格，裡面有員工的名字、部門與薪資：\n如果你只想查出所有人的名字與部門：\nSELECT name, department FROM employees; 🎯 加上條件過濾：WHERE # 如果你只想查薪資大於 60000 的員工，就要用 WHERE 條件語法：\nSELECT name, salary FROM employees WHERE salary \u0026gt; 60000; 這樣會回傳 Bob 的資料。\n🔀 資料排序：ORDER BY\n想把資料照薪資從高到低排列？\nSELECT name, salary FROM employees ORDER BY salary DESC; 加上 DESC（降冪）或 ASC（升冪）就能排序。\n🧯 限制資料筆數：LIMIT\n有些資料表太大，我們不想一口氣撈太多資料，可以用 LIMIT 只抓幾筆：\nSELECT * FROM employees LIMIT 2; 這樣只會抓前兩筆資料。\n👉 如果你用的是 SQL Server，要改用 TOP 或 FETCH 語法；而在 PostgreSQL、MySQL 都支援 LIMIT。\n🧠 組合語法實戰：查出 IT 部門薪資超過 65000 的人，依薪資排序\nSELECT name, department, salary FROM employees WHERE department = \u0026#39;IT\u0026#39; AND salary \u0026gt; 65000 ORDER BY salary DESC; ⚠️ 初學者常見錯誤\n錯誤訊息\t原因說明\nUnknown column \u0026lsquo;Name\u0026rsquo;\tSQL 是區分欄位名稱大小寫的（視資料庫設定），要檢查欄位拼寫是否正確\nSELECT * FROM 少了 ;\t雖然不是所有 DBMS 都強制 ;，但加上它可以避免執行錯誤\n沒加 FROM\tSELECT 一定要指定資料來源表格，否則會報錯\n🪜 SELECT 技能升級任務 # 🎯 初學任務：打開你能操作的資料庫，用 SELECT 查出某張表的前三筆資料、含欄位條件與排序\n你可以使用：\nSQLite + DB Browser（免安裝資料庫伺服器）\nMySQL + Workbench\n或線上工具 like SQL Fiddle\n🧭 小結：SELECT 是資料的入口，千萬別小看它 # 很多人以為 SELECT 很簡單，但其實這是資料查詢世界的「入口語法」。你學會怎麼精準寫 SELECT，也就踏出了進入資料世界的第一步。\n而接下來，你會遇到更強大的工具：WHERE 裡的條件邏輯、模糊查詢、IN、BETWEEN、IS NULL 等等。\n⏭ 下一篇將進入支線 B2： # 🔍 「SQL 條件過濾大全：你會的不只 WHERE，還有 IN、LIKE、BETWEEN 等等進階查詢技巧！」\n📌 喜歡這個系列嗎？按下追蹤、收藏或留言告訴我你最想學的部分，我將持續更新這套 SQL 技能樹，一步步幫你升級資料思維！\n","externalUrl":null,"permalink":"/sql/sql-b1/","section":"SQL學習資料分享","summary":"\u003cp\u003e學 SQL 最直接的一步就是：「我想看資料，那要怎麼寫？」\u003c/p\u003e\n\u003cp\u003e答案只有兩個字：SELECT。\u003c/p\u003e","title":"SQL 學習第三步 SELECT 查詢初探：你要的資料，其實一句話就能叫出來｜SQL 系列支線 ","type":"sql"},{"content":"✨ 什麼是 GROUP BY？ 當我們想要「對某欄位的資料進行分組統計」，例如計算每個部門的員工數或每個產品的總銷售額，這時候就會用到 GROUP BY。\nSELECT department, COUNT(*) AS total_employees FROM employees GROUP BY department; 這段語法的意思是：將員工依照部門分組，並計算每個部門的員工數。\n🎯 GROUP BY 的常見搭配：聚合函數 # 搭配 GROUP BY 使用的函數有：\n函數 說明 COUNT() 計算筆數 SUM() 總和 AVG() 平均 MIN() 最小值 MAX() 最大值 例如：計算每個城市的平均薪資\nSELECT city, AVG(salary) AS avg_salary FROM employees GROUP BY city; 🧠 為什麼需要 HAVING？ WHERE 是在資料進入分組前就過濾，但有時候我們想要「針對分組後的結果」再進行篩選，比如： # 「只想看平均薪資超過 60,000 元的城市」\n這時就需要使用 HAVING：\nSELECT city, AVG(salary) AS avg_salary FROM employees GROUP BY city HAVING AVG(salary) \u0026gt; 60000; 🧩 HAVING 是針對「分組後」的結果再進行過濾。\n🧪 GROUP BY vs HAVING vs WHERE 差在哪？ # 條件 說明 WHERE 過濾原始資料 GROUP BY 分組 HAVING 過濾分組後的資料 SELECT department, COUNT(*) AS total_employees FROM employees WHERE status = \u0026#39;active\u0026#39; -- 原始資料先過濾 GROUP BY department HAVING COUNT(*) \u0026gt; 5; -- 分組後再過濾 🔧 實戰練習 假設你有一個銷售資料表 sales，欄位包含：product, region, amount # 1️⃣ 找出每個產品在各區的總銷售金額：\nSELECT product, region, SUM(amount) AS total_sales FROM sales GROUP BY product, region; 2️⃣ 找出銷售總額超過 10,000 的產品與地區組合：\nSELECT product, region, SUM(amount) AS total_sales FROM sales GROUP BY product, region HAVING SUM(amount) \u0026gt; 10000; 📌 小技巧 \u0026amp; 錯誤排雷 ✅ GROUP BY 後面出現的欄位，SELECT 裡面也應該出現（除非是聚合函數）\n🚫 錯誤：SELECT name, COUNT() FROM employees GROUP BY department 🔧 修正：SELECT department, COUNT() FROM employees GROUP BY department\n✅ 可以 GROUP BY 多個欄位，效果類似「巢狀分類」\n📚 總結 # 語法 用途 GROUP BY 把資料依照欄位分類 HAVING 分組後進一步過濾 WHERE 分組前先過濾原始資料 記住：「WHERE 是先過濾，HAVING 是後過濾。」\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-b3/","section":"SQL學習資料分享","summary":"\u003cp\u003e✨ 什麼是 GROUP BY？\n當我們想要「對某欄位的資料進行分組統計」，例如計算每個部門的員工數或每個產品的總銷售額，這時候就會用到 GROUP BY。\u003c/p\u003e","title":"SQL 學習第五步 GROUP BY 分組查詢與 HAVING 條件：你不能只會 SELECT，要開始做報表了！","type":"sql"},{"content":"⏳ 在資料分析中，時間維度幾乎是必考題。今天我們要學會在 SQL 中處理日期格式，並進行時間切分（例如按年、月、日或時段分析）。\n⌚ 認識日期時間型別 # 大多數資料庫有以下幾種常見的時間型別（名稱依 DBMS 可能略有不同）：\n型別\t說明\nDATE\t僅日期（YYYY-MM-DD）\nTIME\t僅時間（HH:MM:SS）\nDATETIME\t日期 + 時間\nTIMESTAMP\t日期時間 + 時區資訊\n📌 MySQL 與 PostgreSQL 都支援 DATE、TIME、TIMESTAMP，但函數名稱略有不同。 # 🔍 常用日期函數 # 不同資料庫的語法稍有差異，以下以 MySQL / PostgreSQL 為例：\n功能\tMySQL 範例\tPostgreSQL 範例\n取得年份\tYEAR(order_date)\tEXTRACT(YEAR FROM order_date)\n取得月份\tMONTH(order_date)\tEXTRACT(MONTH FROM order_date)\n取得日期\tDAY(order_date)\tEXTRACT(DAY FROM order_date)\n取得星期幾\tDAYOFWEEK(order_date)\tEXTRACT(DOW FROM order_date)\n取得小時\tHOUR(order_time)\tEXTRACT(HOUR FROM order_time)\n日期加減\tDATE_ADD(order_date, INTERVAL 7 DAY)\torder_date + INTERVAL \u0026lsquo;7 days\u0026rsquo;\n🗂️ 按年、月、日切分資料 # 假設有一張 orders 訂單表，欄位包含 order_id, order_date, amount。\n1️⃣ 按月份統計銷售額\nSELECT YEAR(order\\_date) AS year, MONTH(order\\_date) AS month, SUM(amount) AS total\\_sales FROM orders GROUP BY YEAR(order\\_date), MONTH(order\\_date) ORDER BY year, month; 2️⃣ PostgreSQL 範例（用 EXTRACT）：\nSELECT EXTRACT(YEAR FROM order\\_date) AS year, EXTRACT(MONTH FROM order\\_date) AS month, SUM(amount) AS total\\_sales FROM orders GROUP BY year, month ORDER BY year, month; 🕒 按時段切分資料 # 有時候我們需要知道「一天中的哪個時段銷售最好」：\nSELECT HOUR(order\\_time) AS order\\_hour, COUNT(\\*) AS orders\\_count FROM orders GROUP BY order\\_hour ORDER BY order\\_hour; 你也可以將時段分成「早上、中午、下午、晚上」：\nSELECT CASE WHEN HOUR(order\\_time) BETWEEN 6 AND 11 THEN \u0026#39;Morning\u0026#39; WHEN HOUR(order\\_time) BETWEEN 12 AND 17 THEN \u0026#39;Afternoon\u0026#39; WHEN HOUR(order\\_time) BETWEEN 18 AND 23 THEN \u0026#39;Evening\u0026#39; ELSE \u0026#39;Night\u0026#39; END AS time\\_period, COUNT(\\*) AS orders\\_count FROM orders GROUP BY time\\_period; 🛠 日期格式轉換 # 如果日期是以文字存的（例如 \u0026lsquo;2025-08-11\u0026rsquo;），必須先轉成日期型別才能切分。\nMySQL：\nSTR\\_TO\\_DATE(date\\_string, \u0026#39;%Y-%m-%d\u0026#39;) PostgreSQL：\nTO\\_DATE(date\\_string, \u0026#39;YYYY-MM-DD\u0026#39;) 📌 小技巧 \u0026amp; 錯誤排雷 # ✅ 儘量用日期型別儲存時間，避免日後切分出錯\n✅ GROUP BY 時，可以直接用 YEAR()、MONTH() 處理\n🚫 不要在 WHERE 裡用 YEAR(date_col) = 2023 篩選，會讓索引失效\n🔧 正確作法：\nWHERE order\\_date \u0026gt;= \u0026#39;2023-01-01\u0026#39; AND order\\_date \\\u0026lt; \u0026#39;2024-01-01\u0026#39; ","externalUrl":null,"permalink":"/sql/sql-c1/","section":"SQL學習資料分享","summary":"\u003cp\u003e⏳ 在資料分析中，時間維度幾乎是必考題。今天我們要學會在 SQL 中處理日期格式，並進行時間切分（例如按年、月、日或時段分析）。\u003c/p\u003e","title":"SQL 學習第六步 日期格式與時間切分技巧：讓時間分析更精準","type":"sql"},{"content":"當你學會了 SELECT 和基本的 WHERE 條件查詢後，接下來就可以解鎖更強大的查詢語法組合！\n這一篇是 SQL 條件篩選語法的實戰大全，我會帶你用清楚的範例，快速掌握以下查詢神器：\nIN / NOT IN\nLIKE 模糊比對\nBETWEEN 區間查詢\nIS NULL / IS NOT NULL\n邏輯運算子 AND / OR / NOT 的正確用法\n🧲 用 IN 選擇多個條件值（比 OR 還好用） # 假設你要查詢來自「New York、Taipei、Tokyo」三個城市的使用者，你可以用這樣的方式寫：\nsql\nSELECT name, city FROM users WHERE city IN (\u0026#39;New York\u0026#39;, \u0026#39;Taipei\u0026#39;, \u0026#39;Tokyo\u0026#39;); 比起這樣寫會更簡潔：\n-- 傳統寫法（不建議） WHERE city = \u0026#39;New York\u0026#39; OR city = \u0026#39;Taipei\u0026#39; OR city = \u0026#39;Tokyo\u0026#39;; 想排除特定值？用 NOT IN：\nWHERE city NOT IN (\u0026#39;Moscow\u0026#39;, \u0026#39;Paris\u0026#39;) 🔍 用 LIKE 進行模糊搜尋 # 有時候你只知道名字的部分關鍵字，這時候就用 LIKE：\n-- 查所有名字開頭是 A 的人 SELECT name FROM users WHERE name LIKE \u0026#39;A%\u0026#39;; % 和 _ 是什麼意思？\n符號 代表 範例 % 任意長度字元 'A%'：A 開頭 _ 單一字元 'A_'：A 開頭兩字元 -- 查名字中間有 \u0026#34;li\u0026#34; 的人 WHERE name LIKE \u0026#39;%li%\u0026#39; -- 查第二個字是 \u0026#34;a\u0026#34; 的人 WHERE name LIKE \u0026#39;_a%\u0026#39; 📏 用 BETWEEN 查區間（含起始與結尾） 想查 20 到 30 歲的使用者，這樣寫最簡單：\nSELECT name, age FROM users WHERE age BETWEEN 20 AND 30; ⚠️ 注意：BETWEEN 是包含頭尾的，也就是等於 \u0026gt;= 20 AND \u0026lt;= 30\n如果你要排除邊界，請改用：\nWHERE age \u0026gt; 20 AND age \u0026lt; 30 🕳 查出「沒有值」的資料：IS NULL / IS NOT NULL # 在資料庫中，NULL 代表「沒有值」，這跟 \u0026lsquo;\u0026rsquo;（空字串）或 0 不一樣。\n查找地址沒填的人：\nSELECT name FROM users WHERE address IS NULL; 查找地址有填的人：\nWHERE address IS NOT NULL; ❌ 錯誤範例（不能用 = 比較 NULL）：\nsql\n\u0026ndash; 錯誤寫法 WHERE address = NULL 🔗 邏輯運算符的正確使用：AND / OR / NOT 你可以組合條件語句：\nsql\n\u0026ndash; 查年齡 25 以上，來自 New York 的人 WHERE age \u0026gt;= 25 AND city = \u0026lsquo;New York\u0026rsquo; 使用 OR 時，記得用括號避免誤解：\n-- 查來自 London 或 Tokyo，且年齡大於 30 的人 WHERE (city = \u0026#39;London\u0026#39; OR city = \u0026#39;Tokyo\u0026#39;) AND age \u0026gt; 30 使用 NOT 排除條件： -- 查不是 Sales 部門的人 WHERE NOT department = \u0026#39;Sales\u0026#39; ## 🧠 實戰練習題 嘗試使用 IN、BETWEEN、LIKE 組合查詢： -- 查找名字中有 \u0026#34;a\u0026#34;，來自 New York 或 Taipei，且年齡 20～35 歲的使用者 SELECT name, city, age FROM users WHERE name LIKE \u0026#39;%a%\u0026#39; AND city IN (\u0026#39;New York\u0026#39;, \u0026#39;Taipei\u0026#39;) AND age BETWEEN 20 AND 35; ⚠️ 常見陷阱與注意事項 問題\t原因\t解法 LIKE 查不到資料\t有沒有注意大小寫？不同資料庫預設不同\t可用 ILIKE（PostgreSQL）或轉小寫後比對 BETWEEN 包不包含兩端？\t包含兩端\tBETWEEN 10 AND 20 等於 \u0026gt;=10 AND \u0026lt;=20 IN vs = 性能差別？\tIN 用於多值篩選更穩定\t少數條件差異不大，多條件請用 IN\n🧭 小結：熟練這些條件語法，你的查詢將無人能擋 # IN：多值選擇更簡潔\nLIKE：模糊查詢神器\nBETWEEN：區間篩選少不了\nIS NULL：找出資料缺漏\nAND / OR：記得用括號組合條件\n⏭ 下一篇將進入支線 B3： 📊 「GROUP BY 分組查詢與 HAVING 條件：你不能只會 SELECT，要開始做報表了！」\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-b2/","section":"SQL學習資料分享","summary":"\u003cp\u003e當你學會了 SELECT 和基本的 WHERE 條件查詢後，接下來就可以解鎖更強大的查詢語法組合！\u003c/p\u003e","title":"SQL 學習第四步 條件過濾大全：查資料不只是 WHERE，還有 IN、LIKE、BETWEEN！","type":"sql"},{"content":"前幾篇再講解如何insert或update，那接下來要講的就是建立資料表時最重要的KEY了。\n在資料庫設計中，除了欄位名稱與資料型態之外，「約束條件（Constraints）」是保證資料正確性與一致性的關鍵。\n今天我們要深入解析四個最常見的 SQL 約束：\nPRIMARY KEY FOREIGN KEY NOT NULL UNIQUE 這篇文章不只是定義，還會有範例與最佳實務，幫助你在真實專案中正確使用它們。\n1. PRIMARY KEY — 主鍵 # 功能\n唯一識別一筆資料\n不能為 NULL\n一個資料表只能有 一組 PRIMARY KEY（但可以由多個欄位組成複合主鍵）\n範例\nCREATE TABLE Users ( user\\_id INT PRIMARY KEY, username VARCHAR(50) ); 要點\n適合用在唯一辨識資料的欄位，例如 user_id、order_id。\n常搭配 AUTO_INCREMENT（MySQL）或 SERIAL（PostgreSQL）自動生成。\n2. FOREIGN KEY — 外鍵 # 功能\n建立資料表之間的關聯\n保證欄位的值必須存在於另一張表的主鍵中\n用來維護「參考完整性」\n範例\nCREATE TABLE Orders ( order\\_id INT PRIMARY KEY, user\\_id INT, FOREIGN KEY (user\\_id) REFERENCES Users(user\\_id) ); 要點\n外鍵值必須已存在於參照的主鍵表中。\n可搭配 ON DELETE CASCADE、ON UPDATE CASCADE 控制刪改行為。\n3. NOT NULL — 非空約束 # 功能\n限制欄位必須有值\n避免資料遺漏\n範例\nCREATE TABLE Products ( product\\_id INT PRIMARY KEY, product\\_name VARCHAR(100) NOT NULL ); 要點\n適合對關鍵欄位加上限制，例如名稱、價格等必填欄位。\n如果欄位可能沒有值，不要亂加 NOT NULL，以免未來資料無法插入。\n4. UNIQUE — 唯一約束 # 功能\n限制欄位值不能重複\n與 PRIMARY KEY 不同，可以有多個 UNIQUE 欄位\n範例\nCREATE TABLE Employees ( emp\\_id INT PRIMARY KEY, email VARCHAR(100) UNIQUE ); 要點\n適合限制帳號、信箱等必須唯一的欄位。\n可搭配多欄位 複合唯一約束\nsql\nALTER TABLE Employees\nADD CONSTRAINT unique_name_department UNIQUE (name, department_id);\n小結 # 約束 功能 可否 NULL 可否重複 一表可有多個? PRIMARY KEY 唯一識別資料 否 否 否 FOREIGN KEY 建立關聯 是 可重複 可 NOT NULL 禁止空值 否 可重複 可 UNIQUE 限制唯一值 是 否 可 最佳實務建議 # 主鍵必須簡潔，建議用數字或短字串，避免用長文字當主鍵。\n外鍵加上索引，提高查詢效率。\nNOT NULL 用在必填欄位，避免造成插入失敗。\nUNIQUE 結合商業邏輯，不要只因為「好像會重複」就加上。\n","externalUrl":null,"permalink":"/sql/sql-d3/","section":"SQL學習資料分享","summary":"\u003cp\u003e前幾篇再講解如何insert或update，那接下來要講的就是建立資料表時最重要的KEY了。\u003c/p\u003e","title":"SQL 關鍵約束一次搞懂：PRIMARY KEY、FOREIGN KEY、NOT NULL、UNIQUE 完整解析","type":"sql"},{"content":"","externalUrl":null,"permalink":"/series/sql%E5%88%9D%E5%AD%B8/","section":"Series","summary":"","title":"SQL初學","type":"series"},{"content":"在前幾篇，我們已經學會了如何建立資料表（CREATE TABLE），但實際開發中，需求往往會變動，這意味著我們需要「改動」已經存在的資料表。\n這個過程，就是 DDL（Data Definition Language） 的另一個重點：\n修改欄位 刪除欄位 重新命名 刪除整張表 今天，我們會一步步示範這些操作，並分享一些在真實專案中的最佳實務。\n1. 修改欄位（ALTER TABLE \u0026hellip; MODIFY / ALTER COLUMN） # 假設我們有一張 users 資料表，欄位 username 原本是 VARCHAR(20)，但後來需求變成可以輸入更長的名稱。\nALTER TABLE users\nMODIFY username VARCHAR(50);\n注意：在 MySQL 是用 MODIFY，但在 PostgreSQL 則是 ALTER COLUMN \u0026hellip; TYPE。\nPostgreSQL 寫法：\nALTER TABLE users\nALTER COLUMN username TYPE VARCHAR(50);\n2. 新增欄位（ADD COLUMN） # 需求變更很常見，比如我們需要在 users 表中加上 email 欄位：\nALTER TABLE users\nADD COLUMN email VARCHAR(100) NOT NULL;\n小技巧：盡量一次新增所需欄位，減少多次 ALTER TABLE，因為每次 ALTER 都可能影響表結構與效能。\n3. 刪除欄位（DROP COLUMN） # 如果 nickname 欄位不再需要，可以這樣刪除：\nALTER TABLE users\nDROP COLUMN nickname;\n⚠ 風險：刪除欄位是不可逆的，資料會永久消失，務必在刪除前做備份。\n4. 欄位重新命名（RENAME COLUMN） # 欄位名稱可能因為業務邏輯而調整，比如將 username 改成 user_name：\nMySQL 8+：\nALTER TABLE users\nRENAME COLUMN username TO user_name;\nPostgreSQL：\nALTER TABLE users\nRENAME COLUMN username TO user_name;\n5. 刪除整張表（DROP TABLE） # 如果整張表都不再使用，可以直接刪除：\nDROP TABLE users;\n慎用：這會直接刪掉表結構與資料，沒有回收桶。\n6. 真實專案建議 # 先備份 — 在任何刪除或修改表結構前，先做備份（mysqldump、pg_dump）。\n先在測試環境試跑 — 千萬別直接在正式環境 ALTER。\n版本控制資料庫結構 — 可以用 Flyway 或 Liquibase 來做 schema 變更的版本管理。\n與後端工程師溝通 — 表結構的改動可能影響 API 或 ORM。\n7. 小結 # 本篇我們掌握了：\n修改欄位型別 新增/刪除欄位 欄位改名 刪除資料表 在下一篇，我們會進入 階段三 C3（索引 Index），學會如何讓查詢更快 🚀。\n","externalUrl":null,"permalink":"/sql/sql-d2/","section":"SQL學習資料分享","summary":"\u003cp\u003e在前幾篇，我們已經學會了如何建立資料表（CREATE TABLE），但實際開發中，需求往往會變動，這意味著我們需要「改動」已經存在的資料表。\u003c/p\u003e","title":"SQL學習第九步 DDL 新手到高手：讓資料表動起來","type":"sql"},{"content":"學習不只是自行吸收，還需要進行使用\n因此整理文章的同時便是再一次的學習\n","externalUrl":null,"permalink":"/sql/","section":"SQL學習資料分享","summary":"\u003cp\u003e學習不只是自行吸收，還需要進行使用\u003c/p\u003e\n\u003cp\u003e因此整理文章的同時便是再一次的學習\u003c/p\u003e","title":"SQL學習資料分享","type":"sql"},{"content":" 1. Two SumGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.Example 1:Input: nums = [2,7,11,15], target = 9Output: [0,1]Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2:Input: nums = [3,2,4], target = 6Output: [1,2]Example 3:Input: nums = [3,3], target = 6Output: [0,1]\n這題的概念是他會給你一個包含特定長度的陣列跟他的要求值。\n最終要輸出的是是否有任意兩個值相加等同於target\n因此會使用兩層for迴圈來進行判斷兩個數值相加是否等同於target\nclass Solution { public int[] twoSum(int[] nums, int target) { int [] answer=new int[2]; int x=nums[0],y=nums[1]; for(int i=0;i\u0026lt;nums.length-1;i++){ for(int j=i+1;j\u0026lt;nums.length;j++){ if(nums[i]+nums[j]\u0026gt;target){ continue; } if(nums[i]+nums[j]==target){ answer[0]=i; answer[1]=j; return answer; } } } answer[0]=x; answer[1]=y; return answer; } } class Solution(object): def twoSum(self,nums:List[int],target:int)-\u0026gt;List[int]: \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; pair_idx={} for i ,num in enumerate(nums): if target-num in pair_idx: return [i,pair_idx[target-num]] pair_idx[num]=i ","externalUrl":null,"permalink":"/leetcode/1-twosum/","section":"LeetCode解題","summary":"\u003cblockquote\u003e\n\u003cp\u003e1. Two SumGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.Example 1:Input: nums = [2,7,11,15], target = 9Output: [0,1]Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].Example 2:Input: nums = [3,2,4], target = 6Output: [1,2]Example 3:Input: nums = [3,3], target = 6Output: [0,1]\u003c/p\u003e","title":"Two Sum","type":"leetcode"},{"content":"Blowfish 支持基于 Hugo 的所有分类方法。同时，当前的标签预览页也支持展示自定义内容。\n在这里可以为每个分类添加额外的描述信息。查看下面的高级标签页面，了解更多。\n","externalUrl":null,"permalink":"/tags/","section":"标签","summary":"\u003cp\u003eBlowfish 支持基于 Hugo 的所有分类方法。同时，当前的标签预览页也支持展示自定义内容。\u003c/p\u003e","title":"标签","type":"tags"},{"content":"这是高级标记。类似其他 Blowfish 中的其他列表页面，你可以在分类列表页添加自定义内容，这部分内容会显示在顶部。\u0026#x1f680;\n你也可以用这些内容来定义 Hugo 的元数据，比如标题和描述。这些内容可以被用来增强 SEO 或其他目的。\n","externalUrl":null,"permalink":"/tags/advanced/","section":"标签","summary":"\u003cp\u003e这是高级标记。类似其他 Blowfish 中的其他列表页面，你可以在分类列表页添加自定义内容，这部分内容会显示在顶部。\u0026#x1f680;\u003c/p\u003e","title":"高级","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/%E6%95%99%E5%AD%B8/","section":"标签","summary":"","title":"教學","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/%E6%96%B0%E6%89%8B/","section":"标签","summary":"","title":"新手","type":"tags"},{"content":"本書由日本教授 岩本茂樹所寫\n主要由作者本人親身經驗、日常生活、電影情節中提出問題讓人去思考在作品中或行為當中，背後是否有什麼社會學的影響。\n像是男女分工、社會資本、溝通交流在認定一切都是早已決定的前提下，是否從另一個角度看其實並非如此。\n男女分工有許多研究或刻板印象會表示男女分工是建立在男性、女性本能上，然而有專家到了國外村落研究當地文化時，卻發現他們的分工並不是單指有分男性女性，有的村莊以女性狩獵男性育兒，有的村莊男女皆要出外打獵。\n因此專家得出的結論是實際上會有什麼性別該做什麼工作不是因爲實際的性別，而是環境的影響下得到的印象。\n社會資本的通常是根據父母的社經地位決定，對於一些人來說需要特別去做的事，在他人眼中或許只是日常的一塊每日讀書、看音樂劇、國外留學。\n這些定義了所謂正常、優秀、完美的人生，通常跟大部分的人並不一樣，並非所有人都可以對孩子有經濟上的支持，那當人不優秀、不完美成為他人眼中不正常的存在時，就會想要做「反社會」的事。\n藉此表示並非自己不上道，而是社會的規則不適用於自己，但社會的規則還是由多數人決定，選擇了「反社會」道路的人會在社會上更加難以適應。\n因此提出了討厭這個社會，就更要融入這個社會成為裡面的最高層級再改變規則。\n書裡提到了很多社會上的事情，讓人反思的不是這些事的對錯，而是當作這些事或看到人做這些事時，是因為受了什麼影響才產生。\n由於書中使用生活中常見的例子，因此更能感同身受。\n","externalUrl":null,"permalink":"/social/getting-started/","section":"Socials","summary":"\u003cp\u003e本書由日本教授 岩本茂樹所寫\u003c/p\u003e\n\u003cp\u003e主要由作者本人親身經驗、日常生活、電影情節中提出問題讓人去思考在作品中或行為當中，背後是否有什麼社會學的影響。\u003c/p\u003e","title":"鍛鍊思考力 的社會讀本","type":"social"},{"content":" 這是不斷自學的後端工程師，Lisa 的學習分享紀錄 主要是分為AI、資料分析、讀書心得等等 ","externalUrl":null,"permalink":"/","section":"歡迎光臨","summary":"\u003cdiv\u003e\n這是不斷自學的後端工程師，Lisa 的學習分享紀錄\u003cbr/\u003e\n主要是分為AI、資料分析、讀書心得等等\n\u003c/div\u003e\n\u003c!-- \u003clite-youtube videoid=\"SgXhGb-7QbU\" playlabel=\"SgXhGb-7QbU\" params=\"\"\u003e\u003c/lite-youtube\u003e\n --\u003e","title":"歡迎光臨","type":"page"},{"content":"書，不只是讀\n還必須吸收，吸收後反覆咀嚼\n將文字成為自己的一部分\n","externalUrl":null,"permalink":"/read/","section":"讀書心得","summary":"\u003cp\u003e書，不只是讀\u003c/p\u003e\n\u003cp\u003e還必須吸收，吸收後反覆咀嚼\u003c/p\u003e\n\u003cp\u003e將文字成為自己的一部分\u003c/p\u003e\n\u003chr\u003e","title":"讀書心得","type":"read"}]