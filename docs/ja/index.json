






[{"content":" 如何建立虛擬環境 # 下面是假設建立Python 虛擬環境\n第 1 步：建立 Python 虛擬環境 # 虛擬環境就像一個獨立的沙盒，所有安裝的函式庫只會在這個沙盒中生效，不會影響到您系統上其他的 Python 專案。\n開啟終端機(Terminal)。\n使用 conda 建立新的虛擬環境： conda 是 Anaconda 的套件管理器，建立虛擬環境非常方便。我們將建立一個名為 gemini-env 的新環境，並指定使用 Python 3.11 版本，因為它是目前穩定且推薦的版本。\nconda create --name gemini-env python=3.11 系統會詢問您是否確認安裝，請輸入 y 並按下 Enter。\n第 2 步：啟動新的虛擬環境 # 建立完成後，您需要啟動這個虛擬環境，之後的所有操作都將在這個環境中進行。\n啟動 gemini-env 環境：\nconda activate gemini-env ✅ 確認： 成功啟動後，您的終端機提示符前面應該會從 (base) 變成 (gemini-env)。這表示您現在已經在全新的、乾淨的環境中了。\n第 3 步：安裝所有必要的函式庫 # 現在我們在新的虛擬環境中，可以放心地安裝所有開發 Gemini 小程式所需的函式庫了。我們將使用 pip 來安裝，但這次因為環境是乾淨的，不會有舊的依賴衝突。\n確保 pip 本身是最新的：\npython -m pip install --upgrade pip 安裝所有開發 Gemini 後端所需的函式庫： 一次性安裝所有函式庫會更有效率。 pip install fastapi uvicorn python-multipart google-generativeai httpx 💡 備註： 如果您之前遇到 grpcio 的編譯問題，這一次因為我們是在一個乾淨的環境中安裝，通常會順利很多。如果還是遇到問題，可以嘗試使用 conda 來安裝這幾個套件：\nBash\nconda install -c conda-forge google-generativeai httpx 然後再用 pip 安裝其他幾個。\n第 4 步：設定 Gemini API 金鑰 現在環境已經準備好，我們來設定金鑰，以便程式可以正確呼叫 Gemini API。\n建立一個 .env 檔案： 在您的專案資料夾中（也就是您存放 main.py 和 index.html 的地方），建立一個新檔案，並將其命名為 .env。\n編輯 .env 檔案： 在檔案中加入以下內容，並將 您的_GEMINI_API_金鑰 替換為您的實際金鑰：\n程式碼片段\nGEMINI_API_KEY=\u0026ldquo;您的_GEMINI_API_金鑰\u0026rdquo; 安裝 python-dotenv 函式庫： 我們需要這個函式庫來讓 FastAPI 應用程式能夠讀取 .env 檔案中的金鑰。\nBash\npip install python-dotenv 修改 main.py： 在 main.py 的最上方，新增這兩行程式碼來載入 .env 檔案。\nPython\nimport os from dotenv import load_dotenv\nload_dotenv() # 在這裡載入環境變數\n\u0026hellip; 後續的程式碼 # GEMINI_API_KEY = os.getenv(\u0026ldquo;GEMINI_API_KEY\u0026rdquo;, \u0026ldquo;\u0026rdquo;) # 這行可以保留，但現在它會從 .env 讀取金鑰了 # 第 5 步：運行您的 FastAPI 應用程式 現在，所有環境和設定都已完成，您可以運行您的應用程式了。\n在同一個終端機視窗中 (確保 (gemini-env) 仍然是啟動狀態)，導航到您的專案資料夾。\nBash\ncd /您的/專案/資料夾/路徑 運行 Uvicorn 伺服器：\nBash\nuvicorn main:app \u0026ndash;reload 如果一切順利，您會看到 Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) 的訊息。\n如何管理虛擬環境和節省空間 如果您未來不再需要某個專案的虛擬環境，您可以隨時將它移除來釋放空間。\n開啟終端機。\n移除虛擬環境：\nBash\nconda env remove \u0026ndash;name gemini-env 這個命令會完全刪除名為 gemini-env 的虛擬環境，所有安裝在裡面的函式庫也會被一併刪除，並釋放出佔用的儲存空間。\n總結來說，虛擬環境雖然會佔用一些空間，但它提供了一個乾淨、隔離的開發環境，可以避免許多混亂和錯誤，是一個非常值得的選擇。\n這個問題問得很好，要查看您目前有哪些虛擬環境，有兩種常用的 conda 命令可以做到。\n如何查看所有虛擬環境 請在您的 Mac 終端機中，輸入以下任一命令並按下 Enter：\nconda env list\nconda info \u0026ndash;envs\n這兩個命令的功能完全相同，都會列出您所有已建立的虛擬環境。\n輸出範例 當您執行命令後，您會看到類似以下的輸出：\nconda environments: # # base * /Users/1020824woaixiaoxiong/opt/anaconda3 gemini-env /Users/1020824woaixiaoxiong/opt/anaconda3/envs/gemini-env my-project-env /Users/1020824woaixiaoxiong/opt/anaconda3/envs/my-project-env 如何解讀輸出 第一欄 (base, gemini-env, my-project-env)：這是您為虛擬環境取的名字。\n星號 (*)：星號旁邊的環境表示這是您目前正在使用的活動環境 (active environment)。例如，在上面的範例中，base 環境是目前啟動的。\n第二欄 (路徑)：這是每個虛擬環境在您電腦上的實際儲存位置。\n如果您想切換到 gemini-env 環境，只需執行 conda activate gemini-env，然後再次執行 conda env list，您就會看到星號移動到 gemini-env 旁邊了。\n","externalUrl":null,"permalink":"/code/vertual_env/","section":"Codes","summary":"\u003ch1 class=\"relative group\"\u003e如何建立虛擬環境 \n    \u003cdiv id=\"如何建立虛擬環境\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e8%99%9b%e6%93%ac%e7%92%b0%e5%a2%83\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e下面是假設建立Python 虛擬環境\u003c/p\u003e","title":"","type":"code"},{"content":"Given a string s, find the length of the longest substring without duplicate characters.\nExample 1:\nInput: s = \u0026ldquo;abcabcbb\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3.\nExample 2:\nInput: s = \u0026ldquo;bbbbb\u0026rdquo;\nOutput: 1\nExplanation: The answer is \u0026ldquo;b\u0026rdquo;, with the length of 1.\nExample 3:\nInput: s = \u0026ldquo;pwwkew\u0026rdquo;\nOutput: 3\nExplanation: The answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3.\nNotice that the answer must be a substring, \u0026ldquo;pwke\u0026rdquo; is a subsequence and not a substring.\nConstraints:\n0 \u0026lt;= s.length \u0026lt;= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n這題的需求是要找到沒有重複，duplicate代表重複，的最長連續字串。\n在條件裡有寫說，該字串只有英文單字，而英文單字總共26個\n那我們可以建立一個陣列檢查該英文單字是否已經出現過。\nboolean [] visited=new boolean[26]; 建立兩個指針，先都放在開頭，設置一個max當作最長長度\n使用while迴圈只動其中一個。\nint s=0,e=0; while(e\u0026lt;s.length) 當指針e往下一個走時，如果visited沒有看過，那就continue\n否則就要讓s指針前進，直到visited清除看過的痕跡\n在清除之前先計算當前長度是否比較長\nif(visited[s.charAt(e)-\u0026#39;a\u0026#39;]) e++; continue; else max=Math.max(max,e-a); while(visited[s.charAt(e)-\u0026#39;a\u0026#39;]){ visited[s.charAt(s)-\u0026#39;a\u0026#39;]=false; s++; } 那最後在送出答案前在檢查一次答案\nreturn Math.max(max,e-a); 合其來就是\nint [] visited=new int[26]; int s=0,e=0; while(e\u0026lt;s.length){ if(visited[s.charAt(e)-\u0026#39;a\u0026#39;]) continue; else max=Math.max(max,e-a); while(visited[s.charAt(e)-\u0026#39;a\u0026#39;]){ visited[s.charAt(s)-\u0026#39;a\u0026#39;]=false; s++; } } return Math.max(max,e-a); ","externalUrl":null,"permalink":"/leetcode/3-longest-substring-without-repeating-characters/","section":"LeetCode解題","summary":"\u003cp\u003eGiven a string s, find the length of the longest substring without duplicate characters.\u003c/p\u003e\n\u003cp\u003eExample 1:\u003c/p\u003e\n\u003cp\u003eInput: s = \u0026ldquo;abcabcbb\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eOutput: 3\u003c/p\u003e\n\u003cp\u003eExplanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3.\u003c/p\u003e","title":"3. Longest Substring Without Repeating Characters","type":"leetcode"},{"content":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n這題要得到是兩個陣列中的中間值\n為了要得到中間值，將兩個陣列合併\n中間的index即是答案\nclass Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { if(nums1.length\u0026gt;nums2.length){ return findMedianSortedArrays(nums2,nums1); } int len1=nums1.length,len2=nums2.length; int left=0,right=len1; while(left\u0026lt;=right){ int part1=(left+right)/2; int part2=(left+right+1)/2-part1; int maxl1=(part1==0)?Integer.MIN_VALUE : nums1[part1 - 1]; int minr1=(part1==len1)?Integer.MAX_VALUE : nums1[part1]; int maxl2=(part2==0)?Integer.MIN_VALUE : nums2[part2 - 1]; int minr2=(part2==len2)?Integer.MAX_VALUE : nums2[part2]; if(maxl1\u0026lt;=minr2\u0026amp;\u0026amp;maxl2\u0026lt;=minr1){ if((len1+len2)%2==0){ return (Math.max(maxl1,maxl2)+Math.min(minr1,minr2))/2.0 }else{ return (double)Math.max(maxl1,maxl2); } }else if(maxl2\u0026gt;minr2) right=part1-1; else left=part1+1; } return 0.0; } } ","externalUrl":null,"permalink":"/leetcode/4-median-of-two-sorted-arrays/","section":"LeetCode解題","summary":"\u003cp\u003eGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\u003c/p\u003e\n\u003cp\u003eThe overall run time complexity should be O(log (m+n)).\u003c/p\u003e","title":"4. Median of Two Sorted Arrays","type":"leetcode"},{"content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n本題是會給予兩個nodelist，每個node裡包含一個值\n將兩組3個nodelist的值從左到右組成一個自然數\n並將兩組自然數加總後，從左到右回傳nodelist\n解題： # 建立一個\n","externalUrl":null,"permalink":"/leetcode/2-add-two-numbers/","section":"LeetCode解題","summary":"\u003cp\u003eYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\u003c/p\u003e","title":"Add Two Numbers","type":"leetcode"},{"content":"","externalUrl":null,"permalink":"/tags/array/","section":"标签","summary":"","title":"Array","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ja/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":" こちらは background レイアウトのデモです。 レイアウトを変更する\u0026orarr; npx blowfish-tools ","externalUrl":null,"permalink":"/ja/","section":"Blowfish へようこそ! 🎉","summary":"\u003cdiv class=\"flex px-4 py-2 mb-8 text-base rounded-md bg-primary-100 dark:bg-primary-900\"\u003e\n  \u003cspan class=\"flex items-center ltr:pr-3 rtl:pl-3 text-primary-400\"\u003e\n    \n    \n      \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n        \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n    \n      \u003c/span\u003e\n    \n\n  \u003c/span\u003e\n  \u003cspan class=\"flex items-center justify-between grow dark:text-neutral-300\"\u003e\n    \u003cspan class=\"prose dark:prose-invert\"\u003eこちらは \u003ccode id=\"layout\"\u003ebackground\u003c/code\u003e レイアウトのデモです。\u003c/span\u003e\n    \u003cbutton\n      id=\"switch-layout-button\"\n      class=\"px-4 !text-neutral !no-underline rounded-md bg-primary-600 hover:!bg-primary-500 dark:bg-primary-800 dark:hover:!bg-primary-700\"\n    \u003e\n      レイアウトを変更する\u0026orarr;\n    \u003c/button\u003e\n  \u003c/span\u003e\n\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpx blowfish-tools\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003clite-youtube videoid=\"SgXhGb-7QbU\" playlabel=\"SgXhGb-7QbU\" params=\"\"\u003e\u003c/lite-youtube\u003e","title":"Blowfish へようこそ! 🎉","type":"page"},{"content":"","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/code/","section":"Codes","summary":"","title":"Codes","type":"code"},{"content":"✨ 什麼是 GROUP BY？ 當我們想要「對某欄位的資料進行分組統計」，例如計算每個部門的員工數或每個產品的總銷售額，這時候就會用到 GROUP BY。\nSELECT department, COUNT(*) AS total_employees FROM employees GROUP BY department; 這段語法的意思是：將員工依照部門分組，並計算每個部門的員工數。\n🎯 GROUP BY 的常見搭配：聚合函數 # 搭配 GROUP BY 使用的函數有：\n函數 說明 COUNT() 計算筆數 SUM() 總和 AVG() 平均 MIN() 最小值 MAX() 最大值 例如：計算每個城市的平均薪資\nSELECT city, AVG(salary) AS avg_salary FROM employees GROUP BY city; 🧠 為什麼需要 HAVING？ WHERE 是在資料進入分組前就過濾，但有時候我們想要「針對分組後的結果」再進行篩選，比如： # 「只想看平均薪資超過 60,000 元的城市」\n這時就需要使用 HAVING：\nSELECT city, AVG(salary) AS avg_salary FROM employees GROUP BY city HAVING AVG(salary) \u0026gt; 60000; 🧩 HAVING 是針對「分組後」的結果再進行過濾。\n🧪 GROUP BY vs HAVING vs WHERE 差在哪？ # 條件 說明 WHERE 過濾原始資料 GROUP BY 分組 HAVING 過濾分組後的資料 SELECT department, COUNT(*) AS total_employees FROM employees WHERE status = \u0026#39;active\u0026#39; -- 原始資料先過濾 GROUP BY department HAVING COUNT(*) \u0026gt; 5; -- 分組後再過濾 🔧 實戰練習 假設你有一個銷售資料表 sales，欄位包含：product, region, amount # 1️⃣ 找出每個產品在各區的總銷售金額：\nSELECT product, region, SUM(amount) AS total_sales FROM sales GROUP BY product, region; 2️⃣ 找出銷售總額超過 10,000 的產品與地區組合：\nSELECT product, region, SUM(amount) AS total_sales FROM sales GROUP BY product, region HAVING SUM(amount) \u0026gt; 10000; 📌 小技巧 \u0026amp; 錯誤排雷 ✅ GROUP BY 後面出現的欄位，SELECT 裡面也應該出現（除非是聚合函數）\n🚫 錯誤：SELECT name, COUNT() FROM employees GROUP BY department 🔧 修正：SELECT department, COUNT() FROM employees GROUP BY department\n✅ 可以 GROUP BY 多個欄位，效果類似「巢狀分類」\n📚 總結 # 語法 用途 GROUP BY 把資料依照欄位分類 HAVING 分組後進一步過濾 WHERE 分組前先過濾原始資料 記住：「WHERE 是先過濾，HAVING 是後過濾。」\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-b3/","section":"SQL學習資料分享","summary":"\u003cp\u003e✨ 什麼是 GROUP BY？\n當我們想要「對某欄位的資料進行分組統計」，例如計算每個部門的員工數或每個產品的總銷售額，這時候就會用到 GROUP BY。\u003c/p\u003e","title":"GROUP BY 分組查詢與 HAVING 條件：你不能只會 SELECT，要開始做報表了！","type":"sql"},{"content":"","externalUrl":null,"permalink":"/tags/leetcode/","section":"标签","summary":"","title":"Leetcode","type":"tags"},{"content":"LeetCode 是一個知名的在線编程平台，提供豐富的算法和数据结构题目。 無論你是初學者還是求職者，都可以通過刷題提升編程能力，積累實戰經驗，為技術面是做好充足準備。\n","externalUrl":null,"permalink":"/leetcode/","section":"LeetCode解題","summary":"\u003cp\u003eLeetCode 是一個知名的在線编程平台，提供豐富的算法和数据结构题目。\n無論你是初學者還是求職者，都可以通過刷題提升編程能力，積累實戰經驗，為技術面是做好充足準備。\u003c/p\u003e","title":"LeetCode解題","type":"leetcode"},{"content":"學 SQL 最直接的一步就是：「我想看資料，那要怎麼寫？」\n答案只有兩個字：SELECT。\nSELECT 是所有 SQL 語法中的核心，你可以把它當成「我要查詢」的意思，語法結構就像是和資料庫對話：\n📣 「欸，幫我找一下這個表格裡面的這幾個欄位，記得條件是這樣，還有請排序一下。」 # 這篇文章，就是要讓你熟練這句話該怎麼翻成 SQL。\n🧪 最基本的 SELECT 語法長這樣 # SELECT 欄位名稱 FROM 資料表名稱; 範例：\n假設我們有一個 employees 表格，裡面有員工的名字、部門與薪資：\n如果你只想查出所有人的名字與部門：\nSELECT name, department FROM employees; 🎯 加上條件過濾：WHERE # 如果你只想查薪資大於 60000 的員工，就要用 WHERE 條件語法：\nSELECT name, salary FROM employees WHERE salary \u0026gt; 60000; 這樣會回傳 Bob 的資料。\n🔀 資料排序：ORDER BY\n想把資料照薪資從高到低排列？\nSELECT name, salary FROM employees ORDER BY salary DESC; 加上 DESC（降冪）或 ASC（升冪）就能排序。\n🧯 限制資料筆數：LIMIT\n有些資料表太大，我們不想一口氣撈太多資料，可以用 LIMIT 只抓幾筆：\nSELECT * FROM employees LIMIT 2; 這樣只會抓前兩筆資料。\n👉 如果你用的是 SQL Server，要改用 TOP 或 FETCH 語法；而在 PostgreSQL、MySQL 都支援 LIMIT。\n🧠 組合語法實戰：查出 IT 部門薪資超過 65000 的人，依薪資排序\nSELECT name, department, salary FROM employees WHERE department = \u0026#39;IT\u0026#39; AND salary \u0026gt; 65000 ORDER BY salary DESC; ⚠️ 初學者常見錯誤\n錯誤訊息\t原因說明\nUnknown column \u0026lsquo;Name\u0026rsquo;\tSQL 是區分欄位名稱大小寫的（視資料庫設定），要檢查欄位拼寫是否正確\nSELECT * FROM 少了 ;\t雖然不是所有 DBMS 都強制 ;，但加上它可以避免執行錯誤\n沒加 FROM\tSELECT 一定要指定資料來源表格，否則會報錯\n🪜 SELECT 技能升級任務 # 🎯 初學任務：打開你能操作的資料庫，用 SELECT 查出某張表的前三筆資料、含欄位條件與排序\n你可以使用：\nSQLite + DB Browser（免安裝資料庫伺服器）\nMySQL + Workbench\n或線上工具 like SQL Fiddle\n🧭 小結：SELECT 是資料的入口，千萬別小看它 # 很多人以為 SELECT 很簡單，但其實這是資料查詢世界的「入口語法」。你學會怎麼精準寫 SELECT，也就踏出了進入資料世界的第一步。\n而接下來，你會遇到更強大的工具：WHERE 裡的條件邏輯、模糊查詢、IN、BETWEEN、IS NULL 等等。\n⏭ 下一篇將進入支線 B2： # 🔍 「SQL 條件過濾大全：你會的不只 WHERE，還有 IN、LIKE、BETWEEN 等等進階查詢技巧！」\n📌 喜歡這個系列嗎？按下追蹤、收藏或留言告訴我你最想學的部分，我將持續更新這套 SQL 技能樹，一步步幫你升級資料思維！\n","externalUrl":null,"permalink":"/sql/sql-b1/","section":"SQL學習資料分享","summary":"\u003cp\u003e學 SQL 最直接的一步就是：「我想看資料，那要怎麼寫？」\u003c/p\u003e\n\u003cp\u003e答案只有兩個字：SELECT。\u003c/p\u003e","title":"SELECT 查詢初探：你要的資料，其實一句話就能叫出來｜SQL 系列支線 ","type":"sql"},{"content":"","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/social/","section":"Socials","summary":"","title":"Socials","type":"social"},{"content":"","externalUrl":null,"permalink":"/tags/sql/","section":"标签","summary":"","title":"SQL","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/sql-%E7%B3%BB%E5%88%97%E4%B8%80/","section":"标签","summary":"","title":"SQL 系列一","type":"tags"},{"content":"在進入 SQL 語法與資料操作之前，我們要先問自己一個問題：我們到底在處理的是什麼資料？\n這就像是想學開車，你得先知道方向盤、油門與車子是怎麼組成的，而不是一上車就猛踩油門。學習 SQL 的第一步，就是建立正確的資料庫「世界觀」。\n🧱 資料是什麼？一切從「表格」開始 # 很多人初學 SQL 時會覺得它很像 Excel。其實這個聯想沒錯，但不夠精確。\n在關聯式資料庫（Relational Database）中，資料是以「表格」的形式存在。這些表格可以互相連結、拆解、過濾、排序，就像一張張有關聯性的電子試算表。\n表格的構成：\nid name age city 1 Alice 28 New York 2 Bob 34 Tokyo 3 Charlie 22 Taipei 這樣的表格就被稱為一張「資料表（Table）」，每一列是「一筆資料（Row）」，每一欄是「一個欄位（Column）」。你寫 SQL，就是為了去查這些資料、整理這些資料，甚至建立與維護這些表格。\n🔗 為什麼叫「關聯式」資料庫？\n所謂「關聯式」的意思，就是表格與表格之間可以建立關聯（Relationship）。比方說，員工資訊在一張表，部門資訊在另一張表，兩張表可以透過「部門代號」這個欄位互相對應起來。\n這樣的設計讓資料更彈性、可維護性高，也就是：\n不用重複資料（資料表之間可分開管理）\n資料一致性更高（修改部門名稱不需修改每位員工）\n查詢更有彈性（可用 JOIN 將多張表結合查詢）\n🔍 常見的資料庫系統：選一個來玩玩吧！ # SQL 語法幾乎是「跨資料庫系統通用的語言」，但資料庫本身有很多種，像是：\n資料庫系統\t特點\t使用場景\nMySQL\t免費、開源、輕量\t中小企業、網站後端常用\nPostgreSQL\t功能強大、支援地理空間查詢\t科學分析、金融、政府系統\nSQLite\t輕巧、無伺服器、單檔運作\t行動 App、本地小型專案\nSQL Server\t微軟出品、商業整合性高\tWindows 生態系、企業內部系統\nOracle\t高穩定性、複雜功能支援\t大型企業、銀行、保險產業\n對初學者來說，推薦從 MySQL 或 SQLite 入門，因為好安裝、資源多，而且可以快速看到成果。\n❓SQL 和 NoSQL 有什麼不同？ # 很多人在學習資料庫時會看到「NoSQL」這個詞，會不小心混淆。\n簡單來說：\n項目\tSQL（關聯式資料庫）\tNoSQL（非關聯式）\n結構\t表格、欄列\t文件、鍵值對、圖形等\n適合情境\t資料結構穩定、資料之間有關聯\t資料結構彈性、不一定要關聯\n查詢語言\t使用 SQL 語法\t各自有 API 或語法（如 MongoDB 查詢語法）\n常見例子\tMySQL、PostgreSQL\tMongoDB、Firebase、Redis\n在進入大數據與非結構化資料之前，SQL 是打好資料邏輯基礎的必經之路。\n🧭 結語：別急著寫 SQL，先理解你要查的「世界」 # 當你想要學好 SQL，請記得第一步不是打開編輯器，而是：\n想清楚「資料是什麼？它們之間有什麼關係？」\n瞭解你所接觸的資料庫長什麼樣子\n選擇一套你能實際操作的資料庫系統開始練習\n建立好這樣的「資料世界觀」後，你的學習會走得比別人更穩，也更快進入狀況。\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-a1/","section":"SQL學習資料分享","summary":"\u003cp\u003e在進入 SQL 語法與資料操作之前，我們要先問自己一個問題：我們到底在處理的是什麼資料？\u003c/p\u003e","title":"SQL 學習第一步：資料庫世界觀建立｜資料從哪裡來，又為什麼這麼重要？","type":"sql"},{"content":"學 SQL 前，你是不是也曾經困惑：\n「SQL 到底是語言還是工具？」\n「為什麼那麼多人說資料分析第一步是學 SQL？」\n「我學會 SELECT * 就代表會 SQL 了嗎？」\n今天就讓我們用最直白的方式來了解 SQL 是什麼，以及它在資料世界中扮演什麼角色。\n💬 SQL 是什麼？一句話定義它 # SQL 是資料庫的語言，就像 Excel 的公式，是與資料對話的工具。\nSQL，全名是 Structured Query Language（結構化查詢語言），是用來「與關聯式資料庫溝通」的一種語言。\n你可以用它來：\n查資料（查出符合條件的訂單）\n改資料（修改使用者的地址）\n建表格（新增一張記錄報表的表）\n控制權限（讓某些人只能看資料，不能改資料）\n它不只是「查詢」語言，更是一整套資料操作語言。\n🧩 SQL 有哪些「語法模組」？ # SQL 語法可以依功能分類為四大類（別背它們，先理解）：\n你最常用的會是 DQL，也就是查資料的 SELECT，但其他類也會在你維護資料庫時逐漸用上。\n🧠 SQL 的三個核心概念 # 1. SQL 是「聲明式」語言\n你只要說出你想要什麼，資料庫就幫你查出來。\n不像 Python 那樣需要寫 for 迴圈，SQL 更像是：\n「嘿資料庫，幫我找出所有訂單金額大於 $1000 的訂單，按時間排序一下。」\n2. SQL 是跨平台的\n大多數資料庫（MySQL、PostgreSQL、SQL Server）都支援 SQL 語法，只差在一些小細節（函式、語法結構）。你學會一次，大致能通用多個系統。\n3. SQL 是資料分析的核心技能之一\n從後端工程師、資料分析師、資料工程師，到商業分析 PM，幾乎都需要會 SQL，因為只要你要分析「儲存在資料庫中的資料」，你就得透過 SQL 來取得它。\n🧭 小結：SQL 是資料世界的語言起點 # SQL 的重要性，就像網頁前端的 HTML，你可能一開始只會寫 SELECT *，但只要持續練習，你會發現它是資料邏輯最重要的通用語言。\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-a2/","section":"SQL學習資料分享","summary":"\u003cp\u003e學 SQL 前，你是不是也曾經困惑：\u003c/p\u003e\n\u003cp\u003e「SQL 到底是語言還是工具？」\u003c/p\u003e\n\u003cp\u003e「為什麼那麼多人說資料分析第一步是學 SQL？」\u003c/p\u003e","title":"SQL 學習第二步：SQL 是什麼？為什麼資料工程師、分析師都離不開它？","type":"sql"},{"content":"當你學會了 SELECT 和基本的 WHERE 條件查詢後，接下來就可以解鎖更強大的查詢語法組合！\n這一篇是 SQL 條件篩選語法的實戰大全，我會帶你用清楚的範例，快速掌握以下查詢神器：\nIN / NOT IN\nLIKE 模糊比對\nBETWEEN 區間查詢\nIS NULL / IS NOT NULL\n邏輯運算子 AND / OR / NOT 的正確用法\n🧲 用 IN 選擇多個條件值（比 OR 還好用） # 假設你要查詢來自「New York、Taipei、Tokyo」三個城市的使用者，你可以用這樣的方式寫：\nsql\nSELECT name, city FROM users WHERE city IN (\u0026#39;New York\u0026#39;, \u0026#39;Taipei\u0026#39;, \u0026#39;Tokyo\u0026#39;); 比起這樣寫會更簡潔：\n-- 傳統寫法（不建議） WHERE city = \u0026#39;New York\u0026#39; OR city = \u0026#39;Taipei\u0026#39; OR city = \u0026#39;Tokyo\u0026#39;; 想排除特定值？用 NOT IN：\nWHERE city NOT IN (\u0026#39;Moscow\u0026#39;, \u0026#39;Paris\u0026#39;) 🔍 用 LIKE 進行模糊搜尋 # 有時候你只知道名字的部分關鍵字，這時候就用 LIKE：\n-- 查所有名字開頭是 A 的人 SELECT name FROM users WHERE name LIKE \u0026#39;A%\u0026#39;; % 和 _ 是什麼意思？\n符號 代表 範例 % 任意長度字元 'A%'：A 開頭 _ 單一字元 'A_'：A 開頭兩字元 -- 查名字中間有 \u0026#34;li\u0026#34; 的人 WHERE name LIKE \u0026#39;%li%\u0026#39; -- 查第二個字是 \u0026#34;a\u0026#34; 的人 WHERE name LIKE \u0026#39;_a%\u0026#39; 📏 用 BETWEEN 查區間（含起始與結尾） 想查 20 到 30 歲的使用者，這樣寫最簡單：\nSELECT name, age FROM users WHERE age BETWEEN 20 AND 30; ⚠️ 注意：BETWEEN 是包含頭尾的，也就是等於 \u0026gt;= 20 AND \u0026lt;= 30\n如果你要排除邊界，請改用：\nWHERE age \u0026gt; 20 AND age \u0026lt; 30 🕳 查出「沒有值」的資料：IS NULL / IS NOT NULL # 在資料庫中，NULL 代表「沒有值」，這跟 \u0026lsquo;\u0026rsquo;（空字串）或 0 不一樣。\n查找地址沒填的人：\nSELECT name FROM users WHERE address IS NULL; 查找地址有填的人：\nWHERE address IS NOT NULL; ❌ 錯誤範例（不能用 = 比較 NULL）：\nsql\n\u0026ndash; 錯誤寫法 WHERE address = NULL 🔗 邏輯運算符的正確使用：AND / OR / NOT 你可以組合條件語句：\nsql\n\u0026ndash; 查年齡 25 以上，來自 New York 的人 WHERE age \u0026gt;= 25 AND city = \u0026lsquo;New York\u0026rsquo; 使用 OR 時，記得用括號避免誤解：\n-- 查來自 London 或 Tokyo，且年齡大於 30 的人 WHERE (city = \u0026#39;London\u0026#39; OR city = \u0026#39;Tokyo\u0026#39;) AND age \u0026gt; 30 使用 NOT 排除條件： -- 查不是 Sales 部門的人 WHERE NOT department = \u0026#39;Sales\u0026#39; ## 🧠 實戰練習題 嘗試使用 IN、BETWEEN、LIKE 組合查詢： -- 查找名字中有 \u0026#34;a\u0026#34;，來自 New York 或 Taipei，且年齡 20～35 歲的使用者 SELECT name, city, age FROM users WHERE name LIKE \u0026#39;%a%\u0026#39; AND city IN (\u0026#39;New York\u0026#39;, \u0026#39;Taipei\u0026#39;) AND age BETWEEN 20 AND 35; ⚠️ 常見陷阱與注意事項 問題\t原因\t解法 LIKE 查不到資料\t有沒有注意大小寫？不同資料庫預設不同\t可用 ILIKE（PostgreSQL）或轉小寫後比對 BETWEEN 包不包含兩端？\t包含兩端\tBETWEEN 10 AND 20 等於 \u0026gt;=10 AND \u0026lt;=20 IN vs = 性能差別？\tIN 用於多值篩選更穩定\t少數條件差異不大，多條件請用 IN\n🧭 小結：熟練這些條件語法，你的查詢將無人能擋 # IN：多值選擇更簡潔\nLIKE：模糊查詢神器\nBETWEEN：區間篩選少不了\nIS NULL：找出資料缺漏\nAND / OR：記得用括號組合條件\n⏭ 下一篇將進入支線 B3： 📊 「GROUP BY 分組查詢與 HAVING 條件：你不能只會 SELECT，要開始做報表了！」\n📌 如果你喜歡這系列，歡迎留言你想學的內容、收藏這篇文章，或追蹤我讓你持續獲得 SQL 系列更新！\n","externalUrl":null,"permalink":"/sql/sql-b2/","section":"SQL學習資料分享","summary":"\u003cp\u003e當你學會了 SELECT 和基本的 WHERE 條件查詢後，接下來就可以解鎖更強大的查詢語法組合！\u003c/p\u003e","title":"SQL 條件過濾大全：查資料不只是 WHERE，還有 IN、LIKE、BETWEEN！","type":"sql"},{"content":"","externalUrl":null,"permalink":"/series/sql%E5%88%9D%E5%AD%B8/","section":"Series","summary":"","title":"SQL初學","type":"series"},{"content":"學習不只是自行吸收，還需要進行使用\n因此整理文章的同時便是再一次的學習\n","externalUrl":null,"permalink":"/sql/","section":"SQL學習資料分享","summary":"\u003cp\u003e學習不只是自行吸收，還需要進行使用\u003c/p\u003e\n\u003cp\u003e因此整理文章的同時便是再一次的學習\u003c/p\u003e","title":"SQL學習資料分享","type":"sql"},{"content":" 1. Two Sum\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n這題的概念是他會給你一個包含特定長度的陣列跟他的要求值。\n最終要輸出的是是否有任意兩個值相加等同於target\n因此會使用兩層for迴圈來進行判斷兩個數值相加是否等同於target\nclass Solution { public int[] twoSum(int[] nums, int target) { int [] answer=new int[2]; int x=nums[0],y=nums[1]; for(int i=0;i\u0026lt;nums.length-1;i++){ for(int j=i+1;j\u0026lt;nums.length;j++){ if(nums[i]+nums[j]\u0026gt;target){ continue; } if(nums[i]+nums[j]==target){ answer[0]=i; answer[1]=j; return answer; } } } answer[0]=x; answer[1]=y; return answer; } } class Solution(object): def twoSum(self,nums:List[int],target:int)-\u0026gt;List[int]: \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; pair_idx={} for i ,num in enumerate(nums): if target-num in pair_idx: return [i,pair_idx[target-num]] pair_idx[num]=i ","externalUrl":null,"permalink":"/leetcode/1-twosum/","section":"LeetCode解題","summary":"\u003cblockquote\u003e\n\u003cp\u003e1. Two Sum\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou may assume that each input would have exactly one solution, and you may not use the same element twice.\u003c/p\u003e","title":"Two Sum","type":"leetcode"},{"content":"Blowfish は Hugo の分類システムを完全にサポートし、どのような分類システムの設定でも適合できます。このような分類システムのリストは、用語リストの上に表示されるカスタムコンテンツもサポートしています。\nこのエリアはそれぞれの分類システムに追加の説明をする時に利用します。以下の高度なタグを確認して、このコンセプトをさらに発展させる方法をご覧ください。\n","externalUrl":null,"permalink":"/ja/tags/","section":"タグ","summary":"\u003cp\u003eBlowfish は Hugo の分類システムを完全にサポートし、どのような分類システムの設定でも適合できます。このような分類システムのリストは、用語リストの上に表示されるカスタムコンテンツもサポートしています。\u003c/p\u003e","title":"タグ","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/%E6%95%99%E5%AD%B8/","section":"标签","summary":"","title":"教學","type":"tags"},{"content":"こちらは高度なタグです。 Blowfish の他のページの様に、個々の分類条項にカスタムコンテンツの追加やそれを条項リストの一番上に表示することが可能です。\u0026#x1f680;\nタイトルや説明など SEO や他の目的に利用するためのHugo のメタデータを定義するためにこれらのコンテンツページも利用可能です。\n","externalUrl":null,"permalink":"/ja/tags/advanced/","section":"タグ","summary":"\u003cp\u003eこちらは高度なタグです。 Blowfish の他のページの様に、個々の分類条項にカスタムコンテンツの追加やそれを条項リストの一番上に表示することが可能です。\u0026#x1f680;\u003c/p\u003e","title":"高度なタグ","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/%E6%96%B0%E6%89%8B/","section":"标签","summary":"","title":"新手","type":"tags"},{"content":"本書由日本教授 岩本茂樹所寫\n主要由作者本人親身經驗、日常生活、電影情節中提出問題讓人去思考在作品中或行為當中，背後是否有什麼社會學的影響。\n像是男女分工、社會資本、溝通交流在認定一切都是早已決定的前提下，是否從另一個角度看其實並非如此。\n男女分工有許多研究或刻板印象會表示男女分工是建立在男性、女性本能上，然而有專家到了國外村落研究當地文化時，卻發現他們的分工並不是單指有分男性女性，有的村莊以女性狩獵男性育兒，有的村莊男女皆要出外打獵。\n因此專家得出的結論是實際上會有什麼性別該做什麼工作不是因爲實際的性別，而是環境的影響下得到的印象。\n社會資本的通常是根據父母的社經地位決定，對於一些人來說需要特別去做的事，在他人眼中或許只是日常的一塊每日讀書、看音樂劇、國外留學。\n這些定義了所謂正常、優秀、完美的人生，通常跟大部分的人並不一樣，並非所有人都可以對孩子有經濟上的支持，那當人不優秀、不完美成為他人眼中不正常的存在時，就會想要做「反社會」的事。\n藉此表示並非自己不上道，而是社會的規則不適用於自己，但社會的規則還是由多數人決定，選擇了「反社會」道路的人會在社會上更加難以適應。\n因此提出了討厭這個社會，就更要融入這個社會成為裡面的最高層級再改變規則。\n書裡提到了很多社會上的事情，讓人反思的不是這些事的對錯，而是當作這些事或看到人做這些事時，是因為受了什麼影響才產生。\n由於書中使用生活中常見的例子，因此更能感同身受。\n","externalUrl":null,"permalink":"/social/getting-started/","section":"Socials","summary":"\u003cp\u003e本書由日本教授 岩本茂樹所寫\u003c/p\u003e\n\u003cp\u003e主要由作者本人親身經驗、日常生活、電影情節中提出問題讓人去思考在作品中或行為當中，背後是否有什麼社會學的影響。\u003c/p\u003e","title":"鍛鍊思考力 的社會讀本","type":"social"},{"content":"⏳ 在資料分析中，時間維度幾乎是必考題。今天我們要學會在 SQL 中處理日期格式，並進行時間切分（例如按年、月、日或時段分析）。\n⌚ 認識日期時間型別 # 大多數資料庫有以下幾種常見的時間型別（名稱依 DBMS 可能略有不同）：\n型別\t說明\nDATE\t僅日期（YYYY-MM-DD）\nTIME\t僅時間（HH:MM:SS）\nDATETIME\t日期 + 時間\nTIMESTAMP\t日期時間 + 時區資訊\n📌 MySQL 與 PostgreSQL 都支援 DATE、TIME、TIMESTAMP，但函數名稱略有不同。 # 🔍 常用日期函數 # 不同資料庫的語法稍有差異，以下以 MySQL / PostgreSQL 為例：\n功能\tMySQL 範例\tPostgreSQL 範例\n取得年份\tYEAR(order_date)\tEXTRACT(YEAR FROM order_date)\n取得月份\tMONTH(order_date)\tEXTRACT(MONTH FROM order_date)\n取得日期\tDAY(order_date)\tEXTRACT(DAY FROM order_date)\n取得星期幾\tDAYOFWEEK(order_date)\tEXTRACT(DOW FROM order_date)\n取得小時\tHOUR(order_time)\tEXTRACT(HOUR FROM order_time)\n日期加減\tDATE_ADD(order_date, INTERVAL 7 DAY)\torder_date + INTERVAL \u0026lsquo;7 days\u0026rsquo;\n🗂️ 按年、月、日切分資料 # 假設有一張 orders 訂單表，欄位包含 order_id, order_date, amount。\n1️⃣ 按月份統計銷售額\nSELECT YEAR(order\\_date) AS year, MONTH(order\\_date) AS month, SUM(amount) AS total\\_sales FROM orders GROUP BY YEAR(order\\_date), MONTH(order\\_date) ORDER BY year, month; 2️⃣ PostgreSQL 範例（用 EXTRACT）：\nSELECT EXTRACT(YEAR FROM order\\_date) AS year, EXTRACT(MONTH FROM order\\_date) AS month, SUM(amount) AS total\\_sales FROM orders GROUP BY year, month ORDER BY year, month; 🕒 按時段切分資料 # 有時候我們需要知道「一天中的哪個時段銷售最好」：\nSELECT HOUR(order\\_time) AS order\\_hour, COUNT(\\*) AS orders\\_count FROM orders GROUP BY order\\_hour ORDER BY order\\_hour; 你也可以將時段分成「早上、中午、下午、晚上」：\nSELECT CASE WHEN HOUR(order\\_time) BETWEEN 6 AND 11 THEN \u0026#39;Morning\u0026#39; WHEN HOUR(order\\_time) BETWEEN 12 AND 17 THEN \u0026#39;Afternoon\u0026#39; WHEN HOUR(order\\_time) BETWEEN 18 AND 23 THEN \u0026#39;Evening\u0026#39; ELSE \u0026#39;Night\u0026#39; END AS time\\_period, COUNT(\\*) AS orders\\_count FROM orders GROUP BY time\\_period; 🛠 日期格式轉換 # 如果日期是以文字存的（例如 \u0026lsquo;2025-08-11\u0026rsquo;），必須先轉成日期型別才能切分。\nMySQL：\nSTR\\_TO\\_DATE(date\\_string, \u0026#39;%Y-%m-%d\u0026#39;) PostgreSQL：\nTO\\_DATE(date\\_string, \u0026#39;YYYY-MM-DD\u0026#39;) 📌 小技巧 \u0026amp; 錯誤排雷 # ✅ 儘量用日期型別儲存時間，避免日後切分出錯\n✅ GROUP BY 時，可以直接用 YEAR()、MONTH() 處理\n🚫 不要在 WHERE 裡用 YEAR(date_col) = 2023 篩選，會讓索引失效\n🔧 正確作法：\nWHERE order\\_date \u0026gt;= \u0026#39;2023-01-01\u0026#39; AND order\\_date \\\u0026lt; \u0026#39;2024-01-01\u0026#39; ","externalUrl":null,"permalink":"/sql/sql-c1/","section":"SQL學習資料分享","summary":"\u003cp\u003e⏳ 在資料分析中，時間維度幾乎是必考題。今天我們要學會在 SQL 中處理日期格式，並進行時間切分（例如按年、月、日或時段分析）。\u003c/p\u003e","title":"日期格式與時間切分技巧：讓時間分析更精準","type":"sql"},{"content":"書，不只是讀\n還必須吸收，吸收後反覆咀嚼\n將文字成為自己的一部分\n","externalUrl":null,"permalink":"/read/","section":"讀書心得","summary":"\u003cp\u003e書，不只是讀\u003c/p\u003e\n\u003cp\u003e還必須吸收，吸收後反覆咀嚼\u003c/p\u003e\n\u003cp\u003e將文字成為自己的一部分\u003c/p\u003e\n\u003chr\u003e","title":"讀書心得","type":"read"}]